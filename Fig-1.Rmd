---
title: "prostate"
output: pdf_document
date: "2023-10-03"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(data.table)
library(tidyr)  # For gather()
library(tidyverse)
library(ggplot2)
library(survival)
library(forestplot)
library(survminer)
library(umap)
library(ggbeeswarm)
library(ggpubr)
library(igraph)
library(RColorBrewer)
library(scales)
library(cluster)
library(Cairo)
source("~/git/cyftools/R/helpers.R")
source("~/git/cyftools/R/orion_helpers.R")

fcheck <- function(pf, x) {
  return (bitops::bitAnd(as.numeric(pf), as.numeric(x))==as.numeric(x))
}

fcheckor <- function(pf, x) {
  return (bitops::bitAnd(as.numeric(pf), as.numeric(x)) != 0)
}

generate_random_string <- function(string_length = 8) {
  characters <- c(letters, LETTERS, 0:9)  # alphanumeric characters
  random_string <- paste0(sample(characters, string_length, replace = TRUE), collapse = "")
  return(random_string)
}

save_ppdf <- function(g, filename, width=10, height=10) {
  filepath <- paste0("~/Dropbox_HMS/Primary_prostate_CyCIF_TME_manuscript_2023/figsraw/", filename)
  
  ggsave(plot=g, filename=filepath, device=cairo_pdf)
  
  pdf(filepath, useDingbats = FALSE, width, height)
  print(g)
  dev.off()
}

# ggplot theme
theme_jw <- function() {
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text = element_text(color = "black"),
    panel.background = element_rect(fill = "transparent", colour = NA),
    plot.background = element_rect(fill = "transparent", colour = NA) ,
    text = element_text(family = "Helvetica"),
    axis.text.x = element_text(color = "black"),
    axis.text.y = element_text(color = "black"),
    axis.line = element_line(colour = "black"),
    axis.ticks = element_line()
  )
}

gleason_colors=c("Low"="#1b9e77","High"="#7570b3")
```

```{r clinical-data}
library(googlesheets4)
crr <- as.data.table(googlesheets4::read_sheet("https://docs.google.com/spreadsheets/d/1pXzLJkaX2wkJI_uOdgXLaapg1CJlo459G84FRY1pJYI/edit?gid=0#gid=0", sheet="manifest"))
crr[, Gleason2 := c("4 + 4"="8", "3 + 4"="7", "4 + 5"="5", "5 + 3"="5", "5 + 4"="5")[gleason_stage]]

#setnames(crr, "surgery_lymphatic_vascular_invasion","LVI")
#setnames(crr, "surgery_seminal_vesicle","SVI")
#setnames(crr, "surgery_perineural", "PNI")
#setnames(crr, "surgery_lymph_nodes","LNI")
crr[, anyx_high_risk := LNI == "Positive"  | SVI == "Positive" | LVI == "Positive"]

## Fisher's exact
table_data <- crr[, .N, by = .(Gleason, LVI)]
contingency_table <- as.matrix(dcast(table_data, Gleason ~ LVI, value.var = "N", fill = 0)[, -1])
fisher.test(contingency_table)
```

```{r clinical-tile-plot}

# assume your data.table is called 'crr'

# 1) reshape to long form for just age + grade_group
df <- melt(
  crr[, .(Slide_ID, age, grade_group)],
  id.vars      = "Slide_ID",
  measure.vars = c("age", "grade_group"),
  variable.name = "variable",
  value.name    = "value"
)

# 2) pick palettes
# continuous for age
age_pal <- colorRampPalette(brewer.pal(9, "YlOrRd"))(100)
# discrete for grade_group
grp_lvls <- sort(unique(crr$grade_group))
grp_pal  <- brewer.pal(length(grp_lvls), "Set2")

# 3) map each row to an actual hex
df[
  , fill_col := fifelse(
      variable == "age",
      age_pal[ as.numeric(cut(value, breaks = 100)) ],
      grp_pal[ as.integer(factor(value, levels = grp_lvls)) ]
    )
]

# 4) lock x in alphanumeric order, and plot
df[, Slide_ID := factor(Slide_ID, levels = sort(unique(Slide_ID)))]

g <- ggplot(df, aes(x = Slide_ID, y = variable)) +
  geom_tile(aes(fill = fill_col), colour = "white") +
  scale_fill_identity() +
  coord_fixed() +  # forces squares
  labs(x = "Slide ID", y = NULL) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    panel.grid  = element_blank()
  )

```

```{r load-ali-gates}
load("~/Dropbox_HMS/TLS/Datasets/listdatacysift2_Phen_Ki_BT_TCF1.RData")
nn <- names(ldata)

for (i in nn) {
  print(i)
  ab = as.data.table(ldata[[i]])
  ab[, phen_vec := as.factor(phen_vec)]
  ab[, coarse_phen_vec := NULL]
  ab[, LSPid := NULL]
  todel <- c(colnames(ab)[grepl("5r$",colnames(ab)) | grepl("0r$",colnames(ab))],"delaunay_count","CD206","Hoechst","CD68","CD163","CD19","CD20","AMCAR","HMWCK","CD11b","CD11c")
  ab[, (todel) := NULL]
  saveRDS(ab, file=paste0("~/Desktop/Alidata/",i,".rds"), compress=FALSE)
}
alid <- rbindlist(lapply(nn, function(i) {
  ab = readRDS(paste0("~/Desktop/Alidata/",i,".rds"))
    todel <- c(colnames(ab)[grepl("5r$",colnames(ab)) | grepl("0r$",colnames(ab))],"delaunay_count","CD206","Hoechst","CD68","CD163","CD19","CD20","AMCAR","HMWCK","CD11b","CD11c")
  ab[, (todel) := NULL]
  return(ab)
}), fill=TRUE)
saveRDS(alid, "~/Desktop/Alidata/all.rds", compress=FALSE)

png("~/Desktop/tmp.png",width=5000,height=5000)
print(g)
dev.off()

# get the TCF1 gates
dir_path <- "/Users/jeremiahwala/Dropbox_HMS/Primary_prostate_CyCIF_TME_manuscript_2023/primary_data/gates_j"
ab = alid[TCF1gate == TRUE, min(TCF1), by="sid"]
for (i in seq_len(nrow(ab))) {
  sid <- ab[i, sid]
  value <- ab[i, V1]
  file_path <- file.path(dir_path, paste0("LSP", sid, ".phenotype.csv"))
  line_to_add <- paste0("TCF1,", value, ",100000\n")
  cat(line_to_add, file = file_path, append = TRUE)
}

# get the Ki67 gates
dir_path <- "/Users/jeremiahwala/Dropbox_HMS/Primary_prostate_CyCIF_TME_manuscript_2023/primary_data/gates_j"
ab = alid[KiGate == TRUE, min(Ki67), by="sid"]
for (i in seq_len(nrow(ab))) {
  sid <- ab[i, sid]
  value <- ab[i, V1]
  file_path <- file.path(dir_path, paste0("LSP", sid, ".phenotype.csv"))
  line_to_add <- paste0("Ki67,", value, ",100000\n")
  cat(line_to_add, file = file_path, append = TRUE)
}
```

```{r load-all-cells}

load_all_cells <- function(with_markers = FALSE) {
  
  SLIDEID = "Slide_ID"
  files <- list.files(path = "/Users/jeremiahwala/Dropbox_HMS/Primary_prostate_CyCIF_TME_manuscript_2023/primary_data/chain", full.names = TRUE)
  files <- files[grepl("cyf$", files)]
  
  ## loop and read
  dtt <- parallel::mclapply(files, function(f) {
    
    cat(basename(f), " - ", "", "\n")
    #tmpfile <- paste0("/tmp/", generate_random_string(8))
    

    # if no cells in this margin, just return null
    #if (system(paste("cyftools filter", f, " - | cyftools count -"), intern=TRUE)=="0") {
    #  cat("no cells meeting filter criteria for ", basename(f),"\n")
    #  return(data.table())
    #}
  
    # read the full thing
    if (with_markers)
      toview = "-x Hoechst,Ki67,AMCAR,HMWCK,CD19,SMA,CD20,CD11b,CD68,CD163,CD4,CD3d,CD8a,TCF1,FOXP3,PD1,CD57,CD11c,GranzymeB,CD15,HLADR,CD103,CD31,pTBK1,HLAA,CD24,CD44,CD206,dbscan_cluster,tls_id,dist_tumor"
    else
      toview = "-x Hoechst"
    
    dt <- fread(cmd=paste("cyftools view -R", toview, f))
    # set the slide and margin labels
    dt[, (SLIDEID) := sub("^(LSP[0-9]+).*", "\\1", basename(f))]
    return(dt)
  }, mc.cores=8)
  
  dt <- rbindlist(dtt, fill=TRUE)
 
  return(dt)
}

## load the cells
dtt <- load_all_cells(TRUE)
dtt <- merge(dtt, crr[, .(Slide_ID, Gleason)])

## fix the scaling error
dtt[, x_mm := x / 500]
dtt[, y_mm := y / 500]

library(bitops)
dtt[, AMCARp:= fcheck(pflag, 4)]
dtt[, CD20p := fcheck(pflag, 64)]
dtt[, CD3p := fcheck(pflag, 2048)]
dtt[, SMAp := fcheck(pflag, 32)]
dtt[, CD163p := fcheck(pflag, 512)]
dtt[, CD57p := fcheck(pflag, 65536)]
dtt[, CD8PD1TCF1p := fcheck(pflag, 45056)]
dtt[, FOXP3CD3p := fcheck(pflag, 18432)]
dtt[, FOXP3CD3CD4p := fcheck(pflag, 18432 + 1024)]
dtt[, CD11c := fcheck(pflag, 128)]
dtt[, PD1pCD8p := fcheck(pflag, 32768 + 4096)]
```

```{r pd1-by-cell}

themej <- function() {
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text = element_text(color = "black"),
    panel.background = element_rect(fill = "transparent", colour = NA),
    plot.background = element_rect(fill = "transparent", colour = NA),
    text = element_text(family = "Helvetica"),
    axis.text.x = element_text(color = "black"),
    axis.text.y = element_text(color = "black"),
    axis.line = element_line(colour = "black"),
    axis.ticks = element_line()
  )
}

## 
PD1m = 32768
TCF1m = 8192
CD8m = 4096
CD3m = 2048
CD4m = 1024
CD11cm = 131072
CD68m = 256
CD163m = 512
  
## PD1CD8
ab = dtt[tls_id > 0,  
         {
           sum(fcheck(pflag, TCF1m + CD4m + CD3m)) / .N
         }, by=c("sid","tls_id","Gleason")] ## 32 = TLS flag
g <- ggplot(ab, aes(x = Gleason, y = V1, fill = Gleason)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +  # suppress outliers
  geom_jitter(width = 0.2, shape=16, size = 1, alpha = 0.6, height=0) +  # add jittered points
  scale_fill_manual(values = gleason_colors) +  # custom colors
  stat_compare_means(method = "wilcox.test", label.y = 0.01) +  # add p-value
  themej() + 
  theme(legend.position = "none") +
  coord_cartesian(ylim=c(0.00,0.1)) 

#scale_y_log10()
ab = dtt[tls_id > 0,  
         {
           sum(fcheck(pflag, CD11cm) & !fcheck(pflag, CD3m) & !fcheck(pflag, CD68m) & !fcheck(pflag, CD163m)) / .N
         }, by=c("sid","tls_id","Gleason")] ## 32 = TLS flag
g <- ggplot(ab, aes(x = Gleason, y = V1, fill = Gleason)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +  # suppress outliers
  geom_jitter(width = 0.2, shape=16, size = 1, alpha = 0.6, height=0) +  # add jittered points
  scale_fill_manual(values = gleason_colors) +  # custom colors
  stat_compare_means(method = "wilcox.test", label.y = 0.1) +  # add p-value
  themej() + 
  theme(legend.position = "none") +
  coord_cartesian(ylim=c(0.001,0.2)) + 
#scale_y_log10()
pdf("~/Desktop/CD11cCD3NEGCD163NEGCD68NEG_by_N_inside_TLS.pdf", useDingbats = FALSE, width=1.6, height=2.3)
print(g)
dev.off()

## CD8PD1(TCF1) fraction correlation
DENOM=CD3m 
NUMER=CD8m + CD3m + PD1m
abo <- dtt[tls_id == 0, .(PD1CD8_outside = sum(fcheck(pflag, NUMER)) / sum(fcheck(pflag, DENOM))+ 1e-6), by = c("sid","Gleason")]
abi <- dtt[tls_id >  0, .(PD1CD8_inside = sum(fcheck(pflag, NUMER)) / sum(fcheck(pflag, DENOM))+ 1e-6), by = c("sid","Gleason")]
abot <- dtt[tls_id == 0, .(PD1CD8TCF1_outside = sum(fcheck(pflag, TCF1 + NUMER)) / sum(fcheck(pflag, DENOM))+ 1e-6) , by = c("sid","Gleason")]
abit <- dtt[tls_id >  0, .(PD1CD8TCF1_inside = sum(fcheck(pflag, TCF1 + NUMER)) / sum(fcheck(pflag, DENOM))+ 1e-6), by = c("sid","Gleason")]
ab <- Reduce(function(x, y) merge(x, y, by = c("sid", "Gleason")), list(abo, abi, abit, abot))

stats <- ab[, {
  fit <- lm(log10(PD1CD8_inside) ~ log10(PD1CD8_outside))
  s <- summary(fit)
  .(r2 = round(s$r.squared, 3), p = signif(s$coefficients[2, 4], 3))
}, by = Gleason]
statst <- ab[, {
  fit <- lm(log10(PD1CD8TCF1_inside) ~ log10(PD1CD8TCF1_outside))
  s <- summary(fit)
  .(r2 = round(s$r.squared, 3), p = signif(s$coefficients[2, 4], 3))
}, by = Gleason]

# Build plot
g <- ggplot(ab, aes(x = PD1CD8TCF1_outside, y = PD1CD8TCF1_inside, color = Gleason)) +
  scale_color_manual(values = gleason_colors) +
  geom_smooth(method = "lm", se = TRUE) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  themej()+ 
  theme(legend.position="none") + 
  ggtitle(paste0("High: ",statst[Gleason=="High", paste("R2:",r2, "p:", p)], 
               "\nLow: ", statst[Gleason=="Low",  paste("R2:",r2, "p:", p)]))
pdf(paste0("~/Desktop/PD1CD3CD8TCF1_by_CD3_correlation.pdf"), useDingbats = FALSE, width=3, height=3)
print(g)
dev.off()

g <- ggplot(ab, aes(x = PD1CD8_outside, y = PD1CD8_inside, color = Gleason)) +
  scale_color_manual(values = gleason_colors) +
  geom_smooth(method = "lm", se = TRUE) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  themej() +
   theme(legend.position="none") + 
  ggtitle(paste0("High: ",stats[Gleason=="High", paste("R2:",r2, "p:", p)], 
               "\nLow: ", stats[Gleason=="Low",  paste("R2:",r2, "p:", p)]))
pdf(paste0("~/Desktop/PD1CD3CD8_by_CD3_correlation.pdf"), useDingbats = FALSE, width=3, height=3)
print(g)
dev.off()

##CD8PD1 OUTSIDE
ab = dtt[!fcheck(cflag, 32) & fcheck(cflag,8), sum(PD1pCD8p) / .N, by=c("sid")] ## 32 = TLS flag
ab[, Slide_ID := paste0("LSP",sid)]
ab <- merge(ab, crr[, .(Slide_ID, Gleason)])
g <- ggplot(ab, aes(x = Gleason, y = V1, fill = Gleason)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +  # suppress outliers
  geom_jitter(width = 0.2, shape=16, size = 1, alpha = 0.6, height=0) +  # add jittered points
  scale_fill_manual(values = gleason_colors) +  # custom colors
  stat_compare_means(method = "wilcox.test", label.y = 0.1) +  # add p-value
  #themej() + coord_cartesian(ylim=c(0,0.005))
pdf("~/Desktop/PD1CD8_outside_TLS.pdf", useDingbats = FALSE, width=3, height=3)
print(g)
dev.off()

## PD1CD8TCF1
ab = dtt[tls_id == 0 & fcheck(cflag, 8), sum(fcheck(pflag, CD8m + TCF1m + PD1m)) / .N,
         by=c("sid","tls_id")] 
ab[, Slide_ID := paste0("LSP",sid)]
ab <- merge(ab, crr[, .(Slide_ID, Gleason)])
g <- ggplot(ab, aes(x = Gleason, y = V1, fill = Gleason)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +  # suppress outliers
  geom_jitter(width = 0.2, shape=16, size = 1, alpha = 0.6, height=0) +  # add jittered points
  scale_fill_manual(values = gleason_colors) +  # custom colors
  #coord_cartesian(ylim=c(0,0.001)) + 
  stat_compare_means(method = "wilcox.test", label.y = 0.005) +  # add p-value
  themej() + scale_y_continuous(limits=c(0,0.005))
pdf("~/Desktop/PD1CD8_outside_TLS.pdf", useDingbats = FALSE, width=3, height=3)
print(g)
dev.off()

## PD1CD4TCF1
ab = dtt[tls_id > 0, sum(fcheck(pflag, CD4m + TCF1m + 2048)) / .N,
         by=c("sid","tls_id")] 
ab[, Slide_ID := paste0("LSP",sid)]
ab <- merge(ab, crr[, .(Slide_ID, Gleason)])
g <- ggplot(ab, aes(x = Gleason, y = V1, fill = Gleason)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +  # suppress outliers
  geom_jitter(width = 0.2, shape=16, size = 1, alpha = 0.6, height=0) +  # add jittered points
  scale_fill_manual(values = gleason_colors) +  # custom colors
  #coord_cartesian(ylim=c(0,0.001)) + 
  stat_compare_means(method = "wilcox.test", label.y = 0.005) +  # add p-value
  themej() #+ scale_y_continuous(limits=c(0,0.005))
pdf("~/Desktop/CD4CD3TCF1_inside_TLS.pdf", useDingbats = FALSE, width=3, height=3)
print(g)
dev.off()

## PD1CD8TCF1 - normalized by CD8PD1 -- inside TLS
ab = dtt[tls_id > 0, 
         {
           if (sum(fcheck(pflag, CD8m + PD1m )) > 1)
             #sum(fcheck(pflag, CD8m + TCF1m + PD1m)) / sum(fcheck(pflag, CD8m + PD1m )) ## normalized by CD8PD1
             sum(fcheck(pflag, CD8m + TCF1m + PD1m)) / .N ## normalized by all cells in TLS
           else
             -1
         },
         by=c("sid","tls_id")] 

ab[, Slide_ID := paste0("LSP",sid)]
ab <- merge(ab[V1 >= 0], crr[, .(Slide_ID, Gleason)])
g <- ggplot(ab, aes(x = Gleason, y = V1, fill = Gleason)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +  # suppress outliers
  geom_jitter(width = 0.2, shape=16, size = 1, alpha = 0.6, height=0) +  # add jittered points
  scale_fill_manual(values = gleason_colors) +  # custom colors
  #coord_cartesian(ylim=c(0,0.001)) + 
  scale_y_log10() + 
  stat_compare_means(method = "wilcox.test", label.y = 0.005) +  # add p-value
  themej() #+ scale_y_continuous(limits=c(0,0.005))
pdf("~/Desktop/CD4CD3TCF1_inside_TLS.pdf", useDingbats = FALSE, width=3, height=3)
print(g)
dev.off()

## CD11c
ab = dtt[tls_id > 0, sum(fcheck(pflag, 131072)) / .N,
         by=c("sid","tls_id")] 
ab[, Slide_ID := paste0("LSP",sid)]
ab <- merge(ab, crr[, .(Slide_ID, Gleason)])
g <- ggplot(ab, aes(x = Gleason, y = V1, fill = Gleason)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +  # suppress outliers
  geom_jitter(width = 0.2, shape=16, size = 1, alpha = 0.6, height=0) +  # add jittered points
  scale_fill_manual(values = gleason_colors) +  # custom colors
  #coord_cartesian(ylim=c(0,0.001)) + 
  stat_compare_means(method = "wilcox.test", label.y = 0.005) +  # add p-value
  themej() #+ scale_y_continuous(limits=c(0,0.005))
pdf("~/Desktop/CD11c_inside_TLS.pdf", useDingbats = FALSE, width=3, height=3)
print(g)
dev.off()
```

```{r by-gleason-grade}

dtt[fcheck(cflag, 4096), GG := "3+3"]
dtt[fcheck(cflag, 2*4096), GG := "3+4"]
dtt[fcheck(cflag, 4*4096), GG := "4+3"]
dtt[fcheck(cflag, 8*4096), GG := "4+4"]
dtt[fcheck(cflag, 16*4096), GG := "5"]
dtt[bitops::bitAnd(4096+2*4096+4*4096+8*4096+16*4096, cflag)==0, GG := "None"]

dtt[, cd20_prop := sum(fcheck(pflag, 64)) / .N, by="GG"]
dtt[, cd3_prop := sum(fcheck(pflag, 2048)) / .N, by="GG"]
dtt[, cd8_prop := sum(fcheck(pflag, 4096)) / .N, by="GG"]
dtt[, cd4_prop := sum(fcheck(pflag, 1024)) / .N, by="GG"]

ab = dtt[!duplicated(GG)]
ab2 <- melt(ab, id.vars=c("GG"), measure.vars=c("cd20_prop","cd4_prop","cd8_prop"))

##HLAA
#g <- ggplot(dtt[sample(.N, 10e5)], aes(x=GG, y=HLAA)) + geom_boxplot(outliers=FALSE) 

## Aishwarya figure
ab2$variable <- factor(ab2$variable, levels = c("cd20_prop", "cd8_prop", "cd4_prop"))
g <- ggplot(ab2, aes(x=GG, y=value, fill=variable)) + geom_bar(stat="identity", position="stack") + theme_bw() + 
  scale_fill_manual(name="Immune cell", values=c(cd20_prop="#E41A1C",cd4_prop="#377EB8",cd8_prop="#4DAF4A"), labels=c("CD20","CD4","CD8")) + ylab("Total cell fraction")

```

```{r umap}
library(umap)
library(caret)

marker_cols <- c("Ki67", "AMCAR", "HMWCK", "CD19", 
                 "SMA", "CD20", "CD11b", "CD68", "CD163", 
                 "CD4", "CD3d", "CD8a", "TCF1", "FOXP3", 
                 "PD1", "CD57", "CD11c")
id_cols <- c("SlideID","AMCARp","CD20p","CD3p","SMAp","CD163p","CD57p", "pflag","cflag")

# Extract numeric matrix for UMAP
umap_input <- dtt[SlideID != "LSP12629", .SD, .SDcols = c(marker_cols, id_cols)]

hgpc <- crr[Gleason=="High", Slide_ID]

# Run UMAP
set.seed(42)  # For reproducibility
ix <- sample(nrow(umap_input), 50000)
umap_input2 <- umap_input[ix]
scaler <- preProcess(umap_input2[,.SD, .SDcols=marker_cols], method = c("center", "scale"))
scaled_data <- predict(scaler, umap_input2[,.SD, .SDcols=marker_cols])
umap_result <- umap(scaled_data, n_neighbors = 15, min_dist = 0.1, metric = "euclidean")

# Convert to a data frame for plotting
umap_df <- data.table(UMAP1 = umap_result$layout[,1], UMAP2 = umap_result$layout[,2]) 
umap_df <- cbind(umap_df, umap_input2[, .SD, .SDcols = id_cols])
umap_df[, grade := ifelse(SlideID %in% hgpc, "High","Low")]

umap_df[, celltype := fifelse(AMCARp, "AMCAR",
                      fifelse(CD3p, "CD3",
                      fifelse(SMAp, "SMA",
                      fifelse(CD57p, "CD57",
                      fifelse(CD163p, "CD163",
                      fifelse(CD20p, "CD20", "other"))))))]
palette <- c(
  "AMCAR" = "#1b9e77",
  "CD163" = "#d95f02",
  "CD20" = "#7570b3",
  "other" = "#e7298a",
  "SMA" = "#66a61e",
  "CD3" = "#e6ab02",
  "CD57" ="cyan"
)

# Plot using ggplot2
g <- ggplot(umap_df, aes(x = UMAP1, y = UMAP2, 
                         #color = as.factor(celltype))) +
                         color = as.factor(SlideID))) +
  geom_point(alpha = 0.3, size=0.05) +
  theme_minimal() +
  coord_fixed(ratio=1) +
  #scale_color_manual(values=palette) +
  theme_minimal()

save_ppdf(g,filename="umap.pdf", width=6, height=4)
```

```{r master-file-list}
master_files <- list.files(path = "~/Dropbox_HMS/Primary_prostate_CyCIF_TME_manuscript_2023/primary_data/chain", pattern = "cyf$", full.names = TRUE)
stopifnot(length(master_files)==29)
```

```{r cells-per-sample, include=FALSE}

## count the total number of cells in the project
num_cells <- sum(unlist(sapply(master_files, function(f) {
  dt <- fread(cmd=paste("cyftools count", f))
})))

## get cell counts by type
cell_counts_by_type <- rbindlist(lapply(master_files, function(f) {
  cat(basename(f), "\n")
  dt <- fread(cmd=paste("cyftools cellcount", f, "-a 34816 -a 0 -a 3072 -a 6144 -a 2052 -a 20480 -a 18432 -a 17408 - | cyftools view - -R" ))
  setnames(dt, "34816_count", "PD1CD3_count")
  setnames(dt, "0_count", "unclassified_count")
  setnames(dt, "3072_count", "CD3CD4_count")
  setnames(dt, "6144_count", "CD3CD8_count")
  setnames(dt, "2052_count", "AMACRCD3_count")
  setnames(dt, "20480_count", "FOXP3CD8_count")
  setnames(dt, "18432_count", "FOXP3CD3_count")
  setnames(dt, "17408_count", "FOXP3CD4_count")
  dt[, Slide_ID := sub("^(LSP[0-9]+).*", "\\1", basename(f))]
  return(dt)
}))

# Reshape the data to a long format and remove '_count' from Cell_Type
long_data <- cell_counts_by_type %>%
  select(Slide_ID, AMCAR_count, HMWCK_count, SMA_count, CD3d_count, CD8a_count, CD4_count, PD1_count, FOXP3_count, TCF1_count, CD68_count, CD163_count, CD20_count, CD11b_count, CD57_count) %>%
  gather(key = "Cell_Type", value = "Count", -Slide_ID) %>%
  mutate(Cell_Type = gsub("_count", "", Cell_Type))

# Calculate total cells for each Slide_ID
total_cells <- long_data %>%
  group_by(Slide_ID) %>%
  summarize(Total_Count = sum(Count))

## merge in the clinical data
long_data <- merge(data.table::copy(rr)[,.(Slide_ID, Gleason)], long_data, by="Slide_ID", all.x=TRUE)

# Merge total cells with long data
long_data <- merge(long_data, total_cells, by = "Slide_ID")

## order the slides, first by Gleason then by total count
ordered_slide_ids <- long_data %>%
  arrange(Gleason, Total_Count) %>%
  .$Slide_ID %>%
  unique()
long_data$Slide_ID <- factor(long_data$Slide_ID, levels = ordered_slide_ids)

# Define the order of cell types within each color group
cell_order <- c("AMCAR", "HMWCK", "SMA",   # Group A: Greens
                "CD3d", "CD8a", "CD4", "PD1", "FOXP3", "TCF1",   # Group B: Blues
                "CD68", "CD163", "CD20", "CD11b","CD57")  # Group C: Reds

# Ensure long_data Cell_Type is in the specified order
long_data$Cell_Type <- factor(long_data$Cell_Type, levels = cell_order)
long_data <- as.data.table(long_data)

# Define color palettes for each group
colors <- c(rev(brewer.pal(3, "Greens")[1:3]), 
            brewer.pal(6, "Blues")[1:6], 
            brewer.pal(5, "Reds")[1:5])

# Mapping of cell types to colors
color_map <- setNames(colors, c("AMCAR", "HMWCK", "SMA", 
                                "CD3d", "CD8a", "CD4", "PD1", "FOXP3", "TCF1", 
                                "CD68", "CD163", "CD20", "CD11b","CD57"))

# Create the plot
g_cellcounts <- ggplot(long_data, aes(x = Slide_ID, y = Count/1e6, fill = Cell_Type)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = color_map) +
  coord_flip() +
  #facet_wrap(~Gleason, scales="free_y") +
  labs(x = "Slide ID", y = "Cell count (millions)") +
  theme_jw() + 
  theme(#legend.position = c(0.65, 0.3), 
        #legend.justification = c(-0.2, -0.3), # Coordinates relative to the plot area
        #legend.box.margin = margin(6, 6, 6, 6), # Adjust spacing around the legend box if necessary
        #legend.margin = margin(-10, -10, -10, -10),
        text = element_text(family = "Arial"),
        axis.text.x = element_text(color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.title.y = element_text(size = 9, margin = margin(r = 5)),
        axis.title.x = element_text(size = 9, margin = margin(t = 2)),
        plot.title = element_text(size = 9),
        legend.title = element_blank(),
        #legend.spacing.y = unit(1, "cm"),
        legend.text = element_text(size = 9),
        legend.background = element_blank(),
        legend.key = element_blank(),
        axis.line = element_line(colour = "black"),  # Add axis lines
        panel.background = element_rect(fill = "transparent", colour = NA),  # remove panel background
        plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  #scale_y_log10(breaks = 10^seq(4), labels = trans_format("log10", scales::math_format(10^.x)))
  scale_y_continuous(expand = c(0, 0))
save_ppdf(g, "cell_counts_color_bar.pdf", width=5, height=4)

# Calculate the fractions
fraction_data <- long_data %>%
  group_by(Slide_ID, Gleason) %>%
  mutate(Total = sum(Count)) %>%
  ungroup() %>%
  mutate(Fraction = Count / Total)

# Your ggplot code with fractions
g <- ggplot(fraction_data, aes(x = Slide_ID, y = Fraction, fill = Cell_Type)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = color_map) +
  coord_flip() +
  facet_wrap(~Gleason, scales = "free_y") +
  labs(title = "Cell Type Fractions by Slide ID and Cell Type", x = "Slide ID", y = "Fraction") +
  theme_jw()

dtt <- lapply(files, function(f) {
    dt <- fread(cmd=paste("cyftools count",f))
    dt[, Slide_ID := sub("^(LSP[0-9]+).*", "\\1", basename(f))]
    return(dt)
  })
dtr <- rbindlist(dtt)
dtr[, Slide_ID := factor(Slide_ID, levels = Slide_ID[order(V1)])]
g <- ggplot(dtr, aes(x = Slide_ID, y = V1 / 1000)) +
  geom_bar(stat = "identity") +
  coord_flip() +  # Makes the bar chart horizontal
  labs(x = "Slide_ID",
       y = "Total cell count (thousands)") + theme_jw()
save_ppdf(g, "cell_counts_bar.pdf", width=5, height=5)
```

```{r comut}
library(data.table)
library(ggplot2)
library(dplyr)

dt <- fread("~/Sorger/projects/jhu/HE_sheet.csv")
setnames(dt, c("Pre/Post designation","Tumor Present"),c("PrePost","TumorPresent"))
dt <- dt[,.(Slide,Patient,Disease,Mut,PrePost,TumorPresent,Orion_slide,CyCIF_slide)]

setkey(dt, Patient, Slide)
dt[, ID := ifelse(Patient %in% unique(dt$Patient)[seq(1,length(unique(dt$Patient)), by=2)], "1",
                  "0")]

dt[, Orion := ifelse(nchar(Orion_slide) > 0, "Done","Not Done")]
dt[Orion=="Not Done", Orion := ifelse(TumorPresent=="Y","Pending","No tumor")]
dt[, CyCIF := ifelse(nchar(CyCIF_slide) > 0, "Done","Not Done")]
dt[CyCIF=="Not Done", CyCIF := ifelse(TumorPresent=="Y","Pending","No tumor")]

# Transform data to long format including 'ID'
dt_long <- melt(dt, id.vars = c("Slide", "Patient"), variable.name = "Category", value.name = "Value")

# Sort by Patient and Slide
setkey(dt_long, Patient, Slide)
dt_long[, Patient := factor(Patient, levels=unique(Patient))]
dt_long[, Slide := factor(Slide, levels=unique(Slide))]

# Map values to colors including 'ID'
color_map <- c("PD" = "red", "PR" = "green", "SD" = "yellow", 
               "WT" = "purple", "Mut" = "orange", 
               "Pre" = "lightblue", "Post" = "darkblue", 
               "Y" = "green", "N" = "red", 
               "1" = "#e9a3c9", "0" = "#a1d76a",
               "Done"="green","Pending"="yellow","No tumor"="black")
dt_long$Color <- color_map[dt_long$Value]

# Plot with ID category included
g <- ggplot(dt_long, aes(x = Slide, y = Category, fill = Color)) +
  geom_tile(color = "black", linewidth = 0.1) +
  scale_fill_identity() +
  #theme_void() +
  coord_fixed(ratio = 1) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
pdf("~/Sorger/projects/jhu/he_comut.pdf", width=20,height=3)
print(g)
dev.off()

```

```{r qc}

CD20m = 64
CD3m = 2048
CD8m = 4096

#stopifnot("CD4" %in% colnames(dtt))

## CD3 / CD4 / CD8 correlation
dtt[, cd3cd8 := fcheck(pflag, CD3m + CD8m)] 
dtt[, cd3 := fcheck(pflag, CD3m)] #cd3
dtt[, cd8 := fcheck(pflag, CD8m)] # cd8
dtt[, cd8_only := fcheck(pflag, CD8m) & !fcheck(pflag, CD3m)]

## bar plot of cd3/cd8 
result <- dtt[fcheck(cflag, 8), .(cd3cd8_sum_avg = sum(cd3cd8) / .N, cd3_sum_avg = sum(cd3) / .N, cd8_sum_avg = sum(cd8) / .N, cd8only_sum_avg = sum(cd8_only) / .N), by = SlideID]
result[, SlideID := factor(SlideID, levels = SlideID[order(cd3cd8_sum_avg)])]
long_result <- melt(result, id.vars = "SlideID", 
                    measure.vars = c("cd3cd8_sum_avg", "cd8_sum_avg","cd8only_sum_avg"),
                    variable.name = "marker", 
                    value.name = "avg_value")

g <- ggplot(long_result, aes(x = SlideID, y = avg_value, fill = marker), color="black") +
  geom_bar(stat = "identity", position = "dodge", color="black") +
  scale_y_continuous(expand = c(0,0)) + 
  labs(x = "Orion Slide", y = "Average Value", fill = "Marker") +
  theme_jw() + coord_flip() + xlab("Orion Slide ID") + ylab("Fraction of all cells") +  scale_fill_manual(values=c("cd3cd8_sum_avg"="#ca0020","cd8_sum_avg"="#a6d96a","cd8only_sum_avg"="#bcbddc")) 
save_ppdf(g, "cd3_cd8_waterfall.pdf", width=5, height=3.5)

## 2D density map
slides <- unique(dtt$SlideID)
plot_list <- list()

dttt = dtt[SlideID == slide & fcheck(pflag, CD8m)==1 & fcheck(pflag, CD3m)==0]
dttt = dtt[fcheck(pflag, CD8m)==1]
bin_width=0.2
for (slide in slides) {
  cat("...", slide,"\n")
  g <- ggplot(dttt[SlideID==slide], aes(x = x_mm, y = y_mm)) +
    geom_point(data = dtt[SlideID == slide][sample(.N, min(.N, 50000))], 
               size = 0.5, 
               color = "#b0b0b0") +
    geom_bin2d(binwidth = c(bin_width,bin_width), 
               aes(fill = after_stat(count) / (bin_width^2)), alpha=0.5) +
    scale_fill_gradient(low = "blue", high = "red", name = "CD8+ / mmÂ²") +
    coord_fixed(ratio = 1) +  # Preserve aspect ratio
    labs(
      title = slide,
      fill = "Density"
    ) +
    theme_minimal()
  plot_list[[slide]] <- g
}

library(cowplot)
pdf("~/Dropbox_HMS/Primary_prostate_CyCIF_TME_manuscript_2023/figsraw/cd8.pdf", width = 20, height = 35)  # Adjust dimensions as needed
plot_grid(plotlist = plot_list, ncol = 3)  # Arrange in a grid with 3 columns
dev.off()
```

```{r roi-overlap}

dtt[, sum(fcheck(cflag, )), by="SlideID"]

```

```{r cyf-read, include=FALSE}

# read all the data as the means within the tumor compartment
nn <- c("tumor"="-A 8", "stroma"="-N 8","all"="", "scramble_tumor"="-A 8", "scramble_stroma"="-N 8","tumor_margin"="-A 40","stroma_margin"="-A 32 -N 8","scramble_tumor_margin"="-A 40", "scramble_stroma_margin"="-A 32 -N 8","stroma_core"="-N 12", "tumor_core"="-A 8 -N 4")

nn <- c("tumor"="-A 8", "stroma"="-N 8","all"="","tumor_margin"="-A 40", "tumor_core"="-A 8 -N 4")

if (FALSE)
lapply(seq_along(nn), function(n) {
  cat("working on", names(nn)[n],"\n")
    dtt <- parallel::mclapply(master_files, function(f) {
      
    #cat(basename(f), " - ", names(nn)[n], "\n")

    tmpfile <- paste0("/tmp/", generate_random_string(8))

    if (grepl("scramble", names(nn)[n])) {
      ccmd=paste("cyftools scramble",f, "- | cyftools filter -", nn[n], tmpfile)
    } else { 
      ccmd=paste("cyftools filter",f, nn[n],tmpfile)
    }
    system(ccmd)
    
    dt <- fread(cmd=paste("cyftools mean", tmpfile, " - | cyftools view - -R"))

    dt[ , allcount       := fread(cmd=paste("cyftools count", tmpfile))$V1]

    # indivdual cell counts
    drr = fread(cmd=paste("cyftools cellcount", tmpfile," - -a 34816 -a 33792 -a 65540 -a 49152 -a 0 -a 20480 -a 18432 -a 17408 -a 6144 | cyftools view - -R"))
    dt[, amcar_count := drr$AMCAR_count]
    dt[, hmwck_count := drr$HMWCK_count]
    dt[, cd11c_count := drr$CD11c_count]
    dt[, cd68count := drr$CD68_count]
    dt[ ,cd4count. := drr$CD4_count]
    dt[, foxp3count:= drr$FOXP3_count]
    dt[, cd8count  := drr$CD8a_count]
    dt[, cd20count := drr$CD20_count]
    dt[, cd3count := drr$CD3d_count]
    dt[, cd163count := drr$CD163_count]
    dt[, pd1count := drr$`PD1_count`]
    dt[, smacount := drr$SMA_count]
    dt[ , cd3pd1count    := drr$`34816_count`]
    dt[ , cd4pd1count    := drr$`33792_count`]
    dt[ , uncounted    := drr$`0_count`]
    dt[ , AMACRCD57    := drr$`65540_count`]
    dt[ , FOXP3PD1    := drr$`49152_count`]
    dt[,  FOXP3CD8   := drr$`20480_count`]
    dt[, FOXP3CD3   := drr$`18432_count`]
    dt[, FOXP3CD4  := drr$`17408_count`]
    dt[, cd3cd8count  := drr$`6144_count`]

    dt[, Slide_ID := sub("^(LSP[0-9]+).*", "\\1", basename(f))]
    dt[, margin := names(nn)[n]]
    file.remove(tmpfile)
    return(dt)
  }, mc.cores=8)
  dtr <- rbindlist(dtt, fill=TRUE)
  dtr <- dtr[!duplicated(paste(margin, Slide_ID))]
  saveRDS(dtr, paste0("~/Dropbox_HMS/cache/241210_prostate_",names(nn)[n], ".rds"), compress=FALSE)
})

dtr <- rbindlist(lapply(paste0("~/Dropbox_HMS/cache/241210_prostate_",names(nn),".rds"), readRDS), fill=TRUE)
dtr <- dtr[!duplicated(paste(margin, Slide_ID))]
rr <- merge(data.table::copy(crr), dtr, by = "Slide_ID", all.x = TRUE)
#fwrite(rr, "~/Dropbox/Sorger/projects/prostate/240806_prostate_data.csv", sep=",", quote=FALSE)

rr[, CD8_n := cd8count / allcount]
rr[, CD3_n := cd3count / allcount]
rr[, FOXP3PD1_n := FOXP3PD1 / allcount]
rr[, PD1_n := pd1count / allcount]
rr[, FOXP3_n := foxp3count / allcount]
rr[, FOXP3CD8_n := FOXP3CD8 / allcount]
rr[, FOXP3CD3_n := FOXP3CD3 / allcount]
rr[, FOXP3CD4_n := FOXP3CD4 / allcount]
rr[, CD163_n := cd163count / allcount]
rr[, AMCAR_n := amcar_count / allcount]
rr[, AMACRCD57_n := AMACRCD57 / allcount]
```

```{r variance}
bad_samp = paste0("LSP126",c(29))

17, 31
33

var(rr[margin=="tumor" & !Slide_ID %in% bad_samp, CD20_50r])
var(rr[margin=="tumor" & !Slide_ID %in% bad_samp, CD8a_50r])
var(rr[margin=="tumor" & !Slide_ID %in% bad_samp, CD4_50r])

leveneTest(c(rr[Gleason=="Low" & margin=="tumor",CD8a_50r], 
rr[Gleason=="High" & margin=="tumor", CD8a_50r]), 
c(rep("LG",rr[Gleason=="Low" & margin=="tumor",.N]), 
  rep("HG",rr[Gleason=="High" & margin=="tumor",.N])))

var(rr[Gleason=="Low" & margin=="tumor",CD8a_50r])
var(rr[Gleason=="High" & margin=="tumor",CD8a_50r])

var(rr[Gleason=="Low" & margin=="tumor",CD20_50r])
var(rr[Gleason=="High" & margin=="tumor",CD20_50r])

leveneTest(c(rep(rr[Gleason=="Low" & margin=="tumor",CD20_50r], 1), 
rep(rr[Gleason=="High" & margin=="tumor", CD20_50r],1)), 
c(rep("LG",rr[Gleason=="Low" & margin=="tumor",.N * 1]), 
  rep("HG",rr[Gleason=="High" & margin=="tumor",.N * 1])))
```

```{r QC}
dt <- fread(cmd=paste("cyftools filter -a 2048 -o -a 4096 ~/Dropbox/Sorger/projects/prostate/chain_flip_cat.cyf -  | cyftools clean -M - - | cyftools clean -m - - | cyftools view - -R"))

dt[, CD8 := ifelse(bitops::bitAnd(pflag, 4096)==4096, 1, 0)]
dt[, CD3 := ifelse(bitops::bitAnd(pflag, 2048)==2048, 1, 0)]
dt[, SMA := ifelse(bitops::bitAnd(pflag, 32)==32, 1, 0)]
dt[, CD4 := ifelse(bitops::bitAnd(pflag, 1024)==1024, 1, 0)]

cd8_only <- nrow(dt[CD4 == 1 & CD3 == 0])
cd3_only <- nrow(dt[CD4 == 0 & CD3 == 1])
both_cd8_cd3 <- nrow(dt[CD4 == 1 & CD3 == 1])

# Create the Venn diagram
venn.plot <- VennDiagram::draw.pairwise.venn(
  area1 = cd8_only + both_cd8_cd3,
  area2 = cd3_only + both_cd8_cd3,
  cross.area = both_cd8_cd3,
  category = c("CD8", "CD3"),
  scaled = TRUE,
  fill = c("skyblue", "pink"),
  lty = "blank",
  cex = 2,
  cat.cex = 2,
  cat.pos = c(-20, 20),
  cat.dist = c(0.05, 0.05),
  cat.just = list(c(-1, -1), c(1, 1))
)
grid.draw(venn.plot)


# Count the number of occurrences for each category
cd8_only <- nrow(dt[CD8 == 1 & CD3 == 0 & CD4 == 0])
cd3_only <- nrow(dt[CD8 == 0 & CD3 == 1 & CD4 == 0])
cd4_only <- nrow(dt[CD8 == 0 & CD3 == 0 & CD4 == 1])
cd8_cd3 <- nrow(dt[CD8 == 1 & CD3 == 1 & CD4 == 0])
cd8_cd4 <- nrow(dt[CD8 == 1 & CD3 == 0 & CD4 == 1])
cd3_cd4 <- nrow(dt[CD8 == 0 & CD3 == 1 & CD4 == 1])
cd8_cd3_cd4 <- nrow(dt[CD8 == 1 & CD3 == 1 & CD4 == 1])

# Create the Venn diagram
venn.plot <- draw.triple.venn(
  area1 = cd8_only + cd8_cd3 + cd8_cd4 + cd8_cd3_cd4,
  area2 = cd3_only + cd8_cd3 + cd3_cd4 + cd8_cd3_cd4,
  area3 = cd4_only + cd8_cd4 + cd3_cd4 + cd8_cd3_cd4,
  n12 = cd8_cd3 + cd8_cd3_cd4,
  n13 = cd8_cd4 + cd8_cd3_cd4,
  n23 = cd3_cd4 + cd8_cd3_cd4,
  n123 = cd8_cd3_cd4,
  category = c("CD8", "CD3", "CD4"),
  fill = c("skyblue", "pink", "lightgreen"),
  lty = "blank",
  cex = 2,
  cat.cex = 2,
  cat.col = c("skyblue", "pink", "lightgreen"),
  cat.pos = c(-20, 20, 160),
  cat.dist = c(0.05, 0.05, 0.05),
  cat.just = list(c(-1, -1), c(1, 1), c(1, 1))
)
```

```{r whole-slide-bees}
rrt = rr[margin=="all"]
rrm <- melt(rrt, id.vars=c("Slide_ID","Gleason"), measure.vars=c("CD8a_50r","CD3d_50r", "CD4_50r","CD20_50r","CD68_50r","CD163_50r"))
g <- create_beeswarm_plot(rrm, x_var="Gleason", y_var="value", withbox=TRUE) + 
  facet_wrap(~ variable, scale="free") + 
  scale_fill_manual(values=gleason_colors)
```

```{r tls-counts}
mfiles <- list.files(path = "~/Dropbox_HMS/Primary_prostate_CyCIF_TME_manuscript_2023/primary_data/chain/", pattern = "cyf$", full.names = TRUE)
drr <- parallel::mclapply(mfiles, function(f) {
   dt <- fread(cmd=paste("cyftools view",f,"-x tls_id | cut -d',' -f 7 | sort -n | uniq | wc -l"))
   dt[, Slide_ID := sub("^(LSP[0-9]+).*", "\\1", basename(f))]
}, mc.cores=8)
tls <- rbindlist(drr)
setnames(tls, "V1","TLS_count")
tls[, TLS_count := TLS_count - 1] ## 0 is not a TLS
rr <- merge(rr, tls, by="Slide_ID", all.x=TRUE)
```

```{r load-crc-data}
HOMEPATH="~/Dropbox_HMS/projects/orion"

# load from Google Sheets
gopath <- "https://docs.google.com/spreadsheets/d/1VVzcuDDi8_n9NXWFuuUaUR0f9ghpAJO84Ccb31LX-gI/edit?gid=0#gid=0"
crr_crc <- as.data.table(googlesheets4::read_sheet(gopath, sheet="Clinical_data"))
stopifnot(all(!duplicated(crr_crc$Slide_ID)))

# reformat 
crr_crc[, TIL_num := c("absent"=0,"mild"=1,"moderate"=2,"marked"=3)[TIL]]
crr_crc[, mucinous := as.factor(ifelse(grepl("ucinous", Histology), 1, 0))]
crr_crc[, side := {
  if (Location %in% c("Appendix","Cecum","Ascending","Transverse")) { "Right" } else if (Location %in% c("Sigmoid","Descending")) { "Left" }  else { "Rectal" }
}, by="Slide_ID"]
crr_crc$Location <- factor(crr_crc$Location, levels = c("Appendix", "Cecum", "Ascending", "Transverse", "Descending", "Sigmoid", "Rectosigmoid", "Rectum"))
crr_crc[, PFSC := ifelse(crr_crc$PFSCensor==0,1,0)]
crr_crc[, pMMR := factor(ifelse(tipMMR %in% c("tipMMR","tdpMMR"), "pMMR", "dMMR"))]
#crr_crc$Grade <- factor(crr$Grade, levels = c("Low", "High"))
crr_crc[, TIL_num := c("Absent"=0,"Mild"=1,"Moderate"=2,"Marked"=3)[TIL]]
crr_crc[, mucinous := as.factor(ifelse(grepl("ucinous", Histology), 1, 0))]

#####
### Load
#####
files_crc <- list.files(path = file.path(HOMEPATH,"orion_1_74/chain_coy2"), full.names = TRUE)
files_crc <- files_crc[grepl("cyf$", files_crc)]
length(files_crc)
  
nn <- c("tumor_manual"="-A 8", "tls"="-A 32","all"="","pd1"="-a 32768 -A 8", "notls"="-N 32")
      #  "cd3"="-A 4096","cd8"="-A 256","pdl1"="2048","foxp3"="-A 128")

# how to map from flag combos in list of cys files onto biology  
column_mapping = c(cd31count = "CD31_count", cd45count = "CD45_count", cd68count = "CD68_count", cd4count = "CD4_count", foxp3count = "FOXP3_count", cd8count = "CD8a_count", cd45rocount = "CD45RO_count", cd20count = "CD20_count", pdl1count = "PD-L1_count", cd3count = "CD3e_count", cd163count = "CD163_count", pd1count = "PD-1_count", panckcount = "Pan-CK_count", smacount = "SMA_count", pdl1panckcount = "133120_count", pdl1cd163count = "10240_count", cd3pd1count = "36864_count", cd4pd1count = "32832_count",panckcd3count = "135168_count", panckcd8count="131328_count", foxp3cd3count="4224_count", foxp3panckcount="131200_count", foxp3cd4count="192_count", foxp3cd8count="384_count",cd8pd1count = "33024_count")

# outer margin loop 
if (FALSE) 
dum <- lapply(seq_along(nn), function(n) {
  cat("working on ", names(nn)[n], "\n")
  
  # inner cys file loop
  dtt <- mclapply(files_crc, function(f) {
    
    cat(basename(f), " - ", names(nn)[n], "\n")
    tmpfile <- paste0("/tmp/", generate_random_string(8))
    
    # if no cells in this margin, just return null
    if (system(paste("cyftools filter", f, nn[n], " - | cyftools count -"), intern=TRUE)=="0") {
      cat("no cells meeting filter criteria for ", basename(f),"\n")
      return(data.table())
    }
    
    # if its a scramble margin, do the scramble on the fly (with lock)
    if (grepl("scramble", names(nn)[n]) && grepl("lock",names(nn)[n])) {
      ccmd=paste("cyftools scramble -P ",f, "- | cyftools filter -", nn[n], tmpfile)
    # scramble, without lock
    } else if (grepl("scramble", names(nn)[n])) {
      ccmd=paste("cyftools scramble", f,"- | cyftools filter -", nn[n], tmpfile)
    # otherwise do the margin filter
    } else { 
      ccmd=paste("cyftools filter",f, nn[n],tmpfile)
    }
    system(ccmd)
    
    # read the means for that margin
    dt <- fread(cmd=paste("cyftools mean", tmpfile, " - | cyftools view - -R"))
    dt[,c("sid","cid","cflag","pflag","x","y","Hoechst","AF1","CD31","CD45","CD68","Argo550","CD4","FOXP3","CD8a","CD45RO","CD20","PD-L1","CD3e","CD163","E-cadherin","PD-1","Ki67","Pan-CK","SMA","Area","Region") := NULL]
    dt[ , allcount       := fread(cmd=paste("cyftools count", tmpfile))$V1]
    
    # individual cell counts
    drr = fread(cmd=paste("cyftools cellcount", tmpfile," - -a 133120 -a 10240 -a 36864 -a 32832 -a 33024 -a 0 -a 135168 -a 131328 -a 4224 -a 131200 -a 192 -a 384 | cyftools view - -R"))
    drr[,c("sid","cid","cflag","pflag","x","y","Hoechst","AF1","CD31","CD45","CD68","Argo550","CD4","FOXP3","CD8a","CD45RO","CD20","PD-L1","CD3e","CD163","E-cadherin","PD-1","Ki67","Pan-CK","SMA") := NULL]
    setnames(drr, old=column_mapping, new=names(column_mapping))
    dt <- cbind(drr, dt)
    
    # set the slide and margin labels
    dt[, Slide_ID := sub("^(LSP[0-9]+).*", "\\1", basename(f))]
    dt[, margin := names(nn)[n]]
    
    # get proportion of cells interacting
    cff <- paste("cyftools filter", tmpfile)
    cfc <- "cyftools count -"
    dt[,interacting_cd8pd1_PanCKPDL1 := as.integer(system(paste(cff, "-a 33024 -f dist_PanCKPDL1 -L 20 - |",cfc), intern=TRUE))]
    dt[,interacting_pd1_PDL1         := as.integer(system(paste(cff, "-a 32768 -f dist_PanCKPDL1 -L 20 - |",cfc), intern=TRUE))]
    dt[,interacting_pd1_PDL1         := as.integer(system(paste(cff, "-a 32768 -f dist_PDL1 -L 20 - |",cfc), intern=TRUE))]
    dt[,interacting_cd8pd1_PDL1      := as.integer(system(paste(cff, "-a 33024 -f dist_PDL1 -L 20 - |", cfc), intern=TRUE))]
    dt[,interacting_cd3pd1_PDL1      := as.integer(system(paste(cff, "-a 36864 -f dist_PDL1 -L 20 - |", cfc), intern=TRUE))]
    dt[,interacting_cd4pd1_PanCKPDL1 := as.integer(system(paste(cff, "-a 32832 -f dist_PanCKPDL1 -L 20 - |", cfc), intern=TRUE))]
    dt[,interacting_cd4pd1_CD163PDL1 := as.integer(system(paste(cff, "-a 32832 -f dist_CD163PDL1 -L 20 - |", cfc), intern=TRUE))]
    dt[,interacting_cd3pd1_PanCKPDL1 := as.integer(system(paste(cff, "-a 36864 -f dist_PanCKPDL1 -L 20 - |", cfc), intern=TRUE))]
    dt[,interacting_cd3pd1_CD163PDL1 := as.integer(system(paste(cff, "-a 36864 -f dist_CD163PDL1 -L 20 - |", cfc), intern=TRUE))]
    dt[,interacting_pd1_PanCKPDL1    := as.integer(system(paste(cff, "-a 32768 -f dist_PanCKPDL1 -L 20 - |", cfc), intern=TRUE))]
    dt[,interacting_pd1_CD163PDL1    := as.integer(system(paste(cff, "-a 32768 -f dist_CD163PDL1 -L 20 - |", cfc), intern=TRUE))]
    
    # cleanup
    file.remove(tmpfile)
    return(dt)
  }, mc.cores=10)
  
  # paste the margins together
  dtr <- rbindlist(dtt, fill=TRUE)
  dtr <- dtr[!duplicated(paste(margin, Slide_ID))]
  saveRDS(dtr, file.path("~/Dropbox_HMS","cache",paste0("orion_disttls_241216",names(nn)[n], ".rds")), compress=FALSE)
})

# load the saved data
dtr_crc <- rbindlist(lapply(file.path("~/Dropbox_HMS", "cache",paste0("orion_disttls_241216",names(nn),".rds")), readRDS), fill=TRUE)
rrc <- merge(data.table::copy(crr_crc), dtr_crc, by = "Slide_ID", all.x = TRUE)

## Get the median CRC CD8 by MMR status
pMMR_cd8 <- rrc[margin=="tumor_manual" & pMMR=="pMMR", median(CD8_50r)]
dMMR_cd8 <- rrc[margin=="tumor_manual" & pMMR=="dMMR", median(CD8_50r)]
pMMR_cd20 <- rrc[margin=="tumor_manual" & pMMR=="pMMR", median(CD20_50r)]
dMMR_cd20 <- rrc[margin=="tumor_manual" & pMMR=="dMMR", median(CD20_50r)]
pMMR_cd4 <- rrc[margin=="tumor_manual" & pMMR=="pMMR", median(CD4_50r)]
dMMR_cd4 <- rrc[margin=="tumor_manual" & pMMR=="dMMR", median(CD4_50r)]

## do the comparison (High)
wilcox.test(rr[Gleason=="High" & margin=="tumor", CD8a_50r], 
      rrc[margin=="tumor_manual" & pMMR=="dMMR", CD8_50r])
wilcox.test(rr[Gleason=="High" & margin=="tumor", CD8a_50r], 
      rrc[margin=="tumor_manual" & pMMR=="pMMR", CD8_50r])

t.test(rr[Gleason=="High" & margin=="tumor", CD20_50r], 
      rrc[margin=="tumor_manual" & pMMR=="dMMR", CD20_50r])
wilcox.test(rr[Gleason=="High" & margin=="tumor", CD20_50r], 
      rrc[margin=="tumor_manual" & pMMR=="pMMR", CD20_50r])

wilcox.test(rr[Gleason=="Low" & margin=="tumor", CD8a_50r], 
      rrc[margin=="tumor_manual" & pMMR=="pMMR", CD8_50r])
t.test(rr[Gleason=="Low" & margin=="tumor", CD8a_50r], 
      rrc[margin=="tumor_manual" & pMMR=="dMMR", CD8_50r])

t.test(rr[Gleason=="Low" & margin=="tumor", CD20_50r], 
      rrc[margin=="tumor_manual" & pMMR=="dMMR", CD20_50r])
t.test(rr[Gleason=="Low" & margin=="tumor", CD20_50r], 
      rrc[margin=="tumor_manual" & pMMR=="pMMR", CD20_50r])

median(rr[Gleason=="Low" & margin=="tumor", CD8a_50r])
median(rrc[margin=="tumor_manual" & pMMR=="pMMR", CD8_50r])

## do the comparison (Low)
t.test(rr[Gleason=="Low" & margin=="tumor", CD8a_50r], 
      rrc[margin=="tumor_manual" & pMMR=="pMMR", CD8_50r])
mean(rr[Gleason=="Low" & margin=="tumor", CD8a_50r])
mean(rrc[margin=="tumor_manual" & pMMR=="dMMR", CD8_

var(rr[Gleason=="High" & margin=="tumor", CD8a_50r])
var(rrc[margin=="tumor_manual" & pMMR=="dMMR", CD8_50r])

leveneTest(c(rrc[margin=="tumor_manual" & pMMR=="dMMR", CD8_50r], 
rr[Gleason=="High" & margin=="tumor", CD8a_50r]), 
c(rep("CRC",rrc[margin=="tumor_manual" & pMMR=="dMMR",.N]), 
  rep("PC",rr[Gleason=="High" & margin=="tumor",.N])))
```

```{r cd-waterfall}
rrt = rr[margin=="tumor" & !Slide_ID %in% c("LSP12629")]
# "ratio" is not good term, but it's the field we'll be looking at for this plot
rrt[, ratio := CD8_50r]
rrt2 <- rbind(rrt) #, data.table(Slide_ID=c("dMMR","pMMR"), ratio = c(dMMR_cd20, pMMR_cd20), Gleason=c("pMMR","dMMR")), fill=TRUE) ## add CRC
setkeyv(rrt2, "ratio") 
clevels <- rrt2$Slide_ID
rrt2[, Slide_ID := factor(Slide_ID, levels=clevels)]
rrt2[, samplecount := seq(.N)]
tumor_colors <- c(gleason_colors, "pMMR"="#ffeda0", "dMMR"="#fa9fb5")
g <- ggplot(rrt2, aes(x=Slide_ID, y=ratio / 4, fill=Gleason)) + 
  geom_bar(stat="identity", color="black") + ylab("Cells / mm2") + xlab("Sample ID") +
  coord_flip() +  scale_fill_manual(values=tumor_colors) + theme_jw() + 
  theme(axis.line = element_line(), axis.ticks = element_line()) + 
   theme(legend.position = c(0.65, 0.3), 
        legend.justification = c(-0.2, -0.3), # Coordinates relative to the plot area
        legend.box.margin = margin(6, 6, 6, 6), # Adjust spacing around the legend box if necessary
        legend.margin = margin(-10, -10, -10, -10),
        text = element_text(family = "Helvetica"),
        axis.text.x = element_text(color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.title.y = element_text(size = 9, margin = margin(r = 5)),
        axis.title.x = element_text(size = 9, margin = margin(t = 2)),
        plot.title = element_text(size = 9),
        legend.title = element_blank(),
        #legend.spacing.y = unit(1, "cm"),
        legend.text = element_text(size = 9),
        legend.background = element_blank(),
        legend.key = element_blank(),
        axis.line = element_line(colour = "black"),  # Add axis lines
        panel.background = element_rect(fill = "transparent", colour = NA),  # remove panel background
        plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  #scale_x_continuous(expand=c(0,0), breaks=c(0,10,20,30,40,50,60,70)) + 
  scale_y_continuous(expand=c(0,0))
save_ppdf(g, filename="cd4_waterfall_tumor.pdf", width=5, height=5)
```

```{r compare-compartments-counts}

tumorn="tumor_core"
stroman="stroma_core"
tumorns="stroma_core"
stromans="tumor_core"

# Reshape the data to long format for ggplot
long_data <- as.data.table(rr %>%
  gather(key = "Cell_Type", value = "Value", CD8a_50r, CD3d_50r, PD1_50r, FOXP3_50r, AMCAR_50r, CD163_50r,
         CD8_n, CD3_n, FOXP3PD1_n,PD1_n, FOXP3_n, AMCAR_n, CD163_n,AMACRCD57_n) %>%
  mutate(Gleason = factor(Gleason, levels = c("Low", "High"))))

# Calculate the ratio (tumor)
ratio_data <- long_data[margin %in% c(tumorn, tumorns), .(
    tumor_normalized = Value[margin == tumorn] / Value[margin == tumorns]
  ), by = .(Cell_Type, Slide_ID)
]

# Join ratio_data back to long_data for rows where margin is "A8"
new_rows <- long_data[margin == tumorn, on = .(Cell_Type, Slide_ID)]

# Merge the calculated ratios into new_rows
new_rows <- merge(new_rows, ratio_data, by = c("Cell_Type", "Slide_ID"))

# Update the margin and Value columns in new_rows
new_rows[, `:=`(margin = "tumor_normalized", Value = tumor_normalized)]


# Calculate the ratio (stroma)
ratio_data <- long_data[margin %in% c(stroman, stromans), .(
    stroma_normalized = Value[margin == stroman] / Value[margin == stromans]
  ), by = .(Cell_Type, Slide_ID)
]

# Join ratio_data back to long_data for rows where margin is "A8"
new_rows_s <- long_data[margin == stroman, on = .(Cell_Type, Slide_ID)]

# Merge the calculated ratios into new_rows
new_rows_s <- merge(new_rows, ratio_data, by = c("Cell_Type", "Slide_ID"))

# Update the margin and Value columns in new_rows
new_rows_s[, `:=`(margin = "stroma_normalized", Value = stroma_normalized)]

# Add the new rows to the original data.table
long_data <- rbind(long_data, new_rows, new_rows_s, fill = TRUE)


long_data <- long_data[margin %in% c(tumorn,"all",stroman,"tumor_normalized","stroma_normalized")]

# Create an interaction variable for margin and Gleason
long_data$Margin_Gleason <- with(long_data, factor(interaction(margin, Gleason, sep = "-"),
                                                    levels = c("all-Low", "all-High", 
                                                               paste0(tumorn, c("-Low","-High")),
                                                               paste0(stroman,c("-Low","-High")),
                                                               paste0("tumor_normalized",c("-Low","-High")),
                                                               paste0("stroma_normalized",c("-Low","-High")))))
long_data <- long_data[!(Slide_ID == "LSP12657" & Cell_Type =="CD8a_20r") & 
                       !(Slide_ID == "LSP12629" & Cell_Type =="CD20_20r") &
                       !(Slide_ID == "LSP12629" & Cell_Type =="CD163_20r")]

# Define colors for each margin and Gleason level
# Define the main categories and their low and high variants
categories <- c(tumorn, "all",stroman, "tumor_normalized","stroma_normalized")
variants <- c("Low", "High")

# Create a diverging color palette for each main category
# Adjust the number of colors based on your specific needs
palette_A8 <- brewer.pal(3, "Reds")[c(1,3)]
palette_all <- brewer.pal(3, "Greens")[c(1,3)]
palette_N8 <- brewer.pal(3, "Blues")[c(1,3)]
palette_scramble <- brewer.pal(3, "Purples")[c(1,3)]
palette_stroma_scramble <- brewer.pal(3, "Greys")[c(1,3)]

# Combine the palettes
colors <- c(palette_A8, palette_all, palette_N8, palette_scramble, palette_stroma_scramble)

# Construct the final color mapping
margin_colors <- setNames(colors, paste0(rep(categories, each = length(variants)), "-", variants))

# Extract the corresponding names, which are the LSP numbers
lsp_numbers = names(master_files)

g <- ggplot(long_data[Cell_Type %in% 
                        c("CD3_n","CD8_n","FOXP3_n","PD1_n","AMCAR_n","CD163_n","AMACRCD57_n") & 
                        #c("CD8a_50r", "CD3d_50r", "PD1_50r", "FOXP3_50r", "AMCAR_50r", "CD163_50r") & 
                        !Slide_ID %in% c("LSP12631","LSP12643","LSP12645") & 
                        grepl("normalized", Margin_Gleason)], aes(x = Margin_Gleason, y = Value, fill = Margin_Gleason)) +
  geom_boxplot(position = position_dodge2(width = 0.8, preserve = "single")) +
  scale_fill_manual(values = margin_colors) +
  facet_wrap(~ Cell_Type, nrow=1) +
  scale_y_log10() + 
  labs(title = "Boxplots by Cell Type, Margin, and Gleason", x = "Margin - Gleason", y = "Fold-increase") +
 # coord_cartesian(ylim = c(0, 3.5)) +  # Set y-axis limits
  theme_jw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 1, hjust = 1))+
    scale_x_discrete(labels = function(x) {
    ifelse(x == "tumor_normalizedâLow", "Tumor-Low",
    ifelse(x == "tumor_normalizedâHigh", "Tumor-High",
    ifelse(x == "stroma_normalizedâLow", "Stroma-Low",
    ifelse(x == "stroma_normalizedâHigh", "Stroma-High", x))))
  }) +
  geom_hline(aes(yintercept=1))

dtw <- rbindlist(lapply(c("tumor_normalized","stroma_normalized","all","tumor_margin","stroma_margin"), function(mn) {
  rbindlist(lapply(c("CD8a_50r", "CD3d_50r", "PD1_50r", "FOXP3_50r", "AMCAR_50r", "CD163_50r"), function(cell) {
a = long_data[Cell_Type == cell & !Slide_ID %in% c("LSP12631","LSP12643","LSP12645") & Gleason == "High" & margin==mn, Value]
b = long_data[Cell_Type == cell & !Slide_ID %in% c("LSP12631","LSP12643","LSP12645") & Gleason == "Low" & margin==mn, Value]
data.table(p=wilcox.test(a,b)$p.value, margin=mn, cell=cell)
}))
  }))

dtw <- rbindlist(lapply(c("tumor_normalized","stroma_normalized","all","tumor_core","stroma_core"), function(mn) {
  rbindlist(lapply(c("AMACRCD57_n","AMCAR_n","CD163_n","CD3_n","CD8_n","FOXP3_n","PD1_n"), function(cell) {
a = long_data[Cell_Type == cell & !Slide_ID %in% c("LSP12631","LSP12643","LSP12645") & Gleason == "High" & margin==mn, Value]
b = long_data[Cell_Type == cell & !Slide_ID %in% c("LSP12631","LSP12643","LSP12645") & Gleason == "Low" & margin==mn, Value]
data.table(p=t.test(a,b)$p.value, margin=mn, cell=cell)
}))
  }))

save_ppdf(g, "tumor_v_stroma_boxplots_tumor.pdf", width=8, height=4)
```

```{r adaptive-beeswarm}
rrt = rr[margin=="all"]
tcol <- c("CD8a")
rrp <- rrt[, .SD, .SDcols = c(paste0(tcol,"_50r"), "Gleason","Slide_ID")]
rrm <- data.table::melt(rrp, id.vars = c("Gleason","Slide_ID"))
#rrm <- rrm[!(Slide_ID == "LSP12657" & variable=="CD8a_50r")][!(Slide_ID == "LSP12629" & variable=="CD20_50r")][!(Slide_ID == "LSP12629" & variable=="CD163_50r")]
wilcox.test(rrt[Gleason=="High", CD8a_50r],rrt[Gleason=="Low", CD8a_50r])
t.test(rrt[Gleason=="High", CD8a_50r],rrt[Gleason=="Low", CD8a_50r])
g <- create_beeswarm_plot(rrm, x="Gleason", y="value", withbox=TRUE, dx_combos=list(c("High", "Low"))) +
  facet_wrap(rrm$margin, scales="free", nrow=1) + 
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.1))) +
  theme(
  strip.background = element_blank(),
  strip.text = element_text(face = "bold", size = 10) 
) + ylab("Cell Density (cells/mm2)") + 
   theme(text = element_text(family = "Helvetica"),
        axis.text.x = element_text(color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.title.y = element_text(size = 9, margin = margin(r = 5)),
        axis.title.x = element_text(size = 9, margin = margin(t = 2)),
        plot.title = element_text(size = 9),
        panel.background = element_rect(fill = "transparent", colour = NA),  # remove panel background
        plot.background = element_rect(fill = "transparent", colour = NA)
  ) 
save_ppdf(g, "innate_beeswarm.pdf", width=6, height=1.8)
```

```{r cd57-beeswarm}
rrt = rr[margin=="stroma",]
tcol <- c("FOXP3CD3_n","FOXP3CD8_n","FOXP3CD4_n")
#rrp <- rrt[, .SD, .SDcols = c(paste0(tcol,"_50r"), "Gleason","Slide_ID")]
rrp <- rrt[, .SD, .SDcols = c(tcol, "Gleason","Slide_ID")]
rrm <- data.table::melt(rrp, id.vars = c("Gleason","Slide_ID"))
rrm <- rrm[!(Slide_ID == "LSP12657" & variable=="CD8a_50r")][!(Slide_ID == "LSP12629" & variable=="CD20_50r")][!(Slide_ID == "LSP12629" & variable=="CD163_50r")]
g <- create_beeswarm_plot(rrm, x="Gleason", y="value", withbox=TRUE) +
  facet_wrap(rrm$variable, scales="free", nrow=1) + 
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.1))) +
  theme(
  strip.background = element_blank(),
  strip.text = element_text(face = "bold", size = 10) 
) + ylab("Cell Density (cells/mm2)") + 
   theme(text = element_text(family = "Helvetica"),
        axis.text.x = element_text(color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.title.y = element_text(size = 9, margin = margin(r = 5)),
        axis.title.x = element_text(size = 9, margin = margin(t = 2)),
        plot.title = element_text(size = 9),
        panel.background = element_rect(fill = "transparent", colour = NA),  # remove panel background
        plot.background = element_rect(fill = "transparent", colour = NA)
  ) 
save_ppdf(g, "cd57amcar_beeswarm.pdf", width=2, height=1.8)
```

```{r foxp3-beeswarm}
rrt = rr[margin=="all",]
tcol <- c("FOXP3","PD1","CD163")
rrp <- rrt[, .SD, .SDcols = c(paste0(tcol,"_50r"), "Gleason","Slide_ID")]
#rrp <- rrt[, .SD, .SDcols = c(tcol, "Gleason","Slide_ID")]
rrm <- data.table::melt(rrp, id.vars = c("Gleason","Slide_ID"))
rrm <- rrm[!(Slide_ID == "LSP12657" & variable=="CD8a_50r")][!(Slide_ID == "LSP12629" & variable=="CD20_50r")][!(Slide_ID == "LSP12629" & variable=="CD163_50r")]
g <- create_beeswarm_plot(rrm, x="Gleason", y="value", withbox=TRUE) +
  facet_wrap(rrm$variable, scales="free", nrow=1) + 
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.1))) +
  theme(
  strip.background = element_blank(),
  strip.text = element_text(face = "bold", size = 10) 
) + ylab("Cell Density (cells/mm2)") + 
   theme(text = element_text(family = "Helvetica"),
        axis.text.x = element_text(color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.title.y = element_text(size = 9, margin = margin(r = 5)),
        axis.title.x = element_text(size = 9, margin = margin(t = 2)),
        plot.title = element_text(size = 9),
        panel.background = element_rect(fill = "transparent", colour = NA),  # remove panel background
        plot.background = element_rect(fill = "transparent", colour = NA)
  ) 
save_ppdf(g, "innate_beeswarm_stroma.pdf", width=4, height=1.8)
```

```{r tls-individual-cells}

gby = c("tls_id", "SlideID")
dtt_tls <- dtt[fcheck(cflag, 32)]
dtt_tls[, AMCARp_n  := sum(fcheck(pflag, 4) / .N), by=gby]
dtt_tls[, CD20p   := sum(fcheck(pflag, 64) / .N), by=gby]
dtt_tls[, CD3p    := sum(fcheck(pflag, 2048) / .N), by=gby]
dtt_tls[, SMAp    := sum(fcheck(pflag, 32) / .N), by=gby]
dtt_tls[, CD163p  := sum(fcheck(pflag, 512) / .N), by=gby]
dtt_tls[, CD57p   := sum(fcheck(pflag, 65536) / .N), by=gby]
dtt_tls[, CD8PD1TCF1p := sum(fcheck(pflag, 45056) / .N), by=gby]
dtt_tls[, FOXP3CD3p   := sum(fcheck(pflag, 18432) / .N), by=gby]
dtt_tls[, CD11c       := sum(fcheck(pflag, 128) / .N), by=gby]
```

```{r tls-pd1} 
rrt = rr[margin=="all",]
g <- ggplot(rrt, aes(x=CD8aPD1_50r, y=TLS_count, color=Gleason, fill=Gleason)) + 
  theme_jw() + geom_point() + 
    geom_smooth(method = "lm", se = TRUE) +  # Add linear regression line for each group
  scale_color_manual(values=gleason_colors) + 
  scale_fill_manual(values=gleason_colors) + 
  xlab("CD3+PD1+ cells/mm2") + ylab("Tertiary Lymphoid Structures (count per sample)")
save_ppdf(g, "tls_pd1_correlation.pdf", width=3, height=3)

library(broom)
library(dplyr)
pvals <- rrt %>%
  group_by(Gleason) %>%
  do(tidy(lm(TLS_count ~ CD3PD1_50r, data = .))) %>%
  filter(term == "CD3PD1_50r") %>%
  select(Gleason, estimate, p.value)
```

```{r compare-compartments}

# Reshape the data to long format for ggplot
long_data <- as.data.table(rr[!is.na(margin) & margin %in% c("all","A8","N8","tumor_margin","tumor_stroma")] %>%
  gather(key = "Cell_Type", value = "Value", CD3d_20r, CD20_20r, CD8a_20r,
         AMCAR_20r, CD57_20r, CD163_20r, PD1_20r, CD8a_20r, FOXP3_20r, HLAA_20r, HLADR_20r,
         CD8_n, CD3_n, FOXP3PD1_n) %>%
  mutate(Gleason = factor(Gleason, levels = c("Low", "High"))))

# Create an interaction variable for margin and Gleason
long_data$Margin_Gleason <- with(long_data, factor(interaction(margin, Gleason, sep = "-"),
                                                    levels = c("all-Low", "all-High", "A8-Low", "A8-High","N8-Low", "N8-High","tumor_stroma-Low","tumor_stroma-High","tumor_margin-Low","tumor_margin-High")
                                                    
                                                   ))
long_data <- long_data[!(Slide_ID == "LSP12657" & Cell_Type =="CD8a_20r") & 
                       !(Slide_ID == "LSP12629" & Cell_Type =="CD20_20r") &
                       !(Slide_ID == "LSP12629" & Cell_Type =="CD163_20r")]

# Define colors for each margin and Gleason level
# Define the main categories and their low and high variants
categories <- c("A8", "all", "N8","tumor_stroma","tumor_margin")
variants <- c("Low", "High")

# Create a diverging color palette for each main category
# Adjust the number of colors based on your specific needs
palette_A8 <- brewer.pal(3, "Reds")[c(1,3)]
palette_all <- brewer.pal(3, "Greens")[c(1,3)]
palette_N8 <- brewer.pal(3, "Blues")[c(1,3)]
palette_ts <- brewer.pal(3, "Purples")[c(1,3)]
palette_tm <- brewer.pal(3, "Greys")[c(1,3)]

# Combine the palettes
colors <- c(palette_A8, palette_all, palette_N8, palette_ts, palette_tm)

# Construct the final color mapping
margin_colors <- setNames(colors, paste0(rep(categories, each = length(variants)), "-", variants))

g <- ggplot(long_data[Cell_Type %in% c("CD8a_20r")], aes(x = Margin_Gleason, y = Value, fill = Margin_Gleason)) +
  geom_boxplot(position = position_dodge2(width = 0.8, preserve = "single")) +
  scale_fill_manual(values = margin_colors) +
  facet_wrap(~ Cell_Type, nrow=1) +
  labs(title = "Boxplots by Cell Type, Margin, and Gleason", x = "Margin - Gleason", y = "Cells / mm2") +
  coord_cartesian(ylim = c(0, 2300)) +  # Set y-axis limits
  theme_jw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))

# calculate the wilcox p values
variables <- c("FOXP3_20r", "CD8a_20r", "PD1_20r", "CD163_20r","CD4_20r","CD103_20r", 
               "CD20_20r")
margins <- c("all", "N8", "A8")
rr_subset <- rr[!is.na(margin) & Slide_ID != "LSP12629",]
results <- rbindlist(lapply(variables, function(A) {
  rbindlist(lapply(margins, function(B) {
    data.table(
      Cell = sub("_20r", "", A),
      Compartment = c("all"="Whole slide", "N8"="Stroma","A8"="Tumor")[B],
      p_value = t.test(
        rr_subset[margin == B & Gleason == "Low", get(A)],
        rr_subset[margin == B & Gleason == "High", get(A)]
      )$p.value,
      LG_median = round(rr_subset[margin == B & Gleason == "Low", mean(get(A), na.rm = TRUE)])/1000,
      HG_median = round(rr_subset[margin == B & Gleason == "High", mean(get(A), na.rm = TRUE)])/1000
    )
  }))
}))

results <- results[, c("Cell", "Compartment", "LG_median", "HG_median", "p_value")]
digits <- rep(2, ncol(results)+1)
digits[6] <- 4
latex_table <- xtable(results, digits = digits)
print(latex_table, include.rownames = FALSE, hline.after = c(-1, 0, nrow(data)))

# Write to CSV
fwrite(results, file = "~/Sorger/projects/prostate/formatted_results.csv")

save_ppdf(g, "boxplot_region_compar.pdf", width=8, height=8)
```

```{r 20r-boxplots}
rr_long <- melt(rr, id.vars = "Gleason", measure.vars = c("FOXP3_20r","HLAA_20r"), variable.name = "Metric", value.name = "Value")
rr_long[, cells_per_mm2 := Value * 1e6 / (1000^2 * 0.325^2)]

# Assuming the data has two Gleason groups "A" and "B"
get_pvalue <- function(data){
  wilcox.test(data[data$Gleason == "High",]$cells_per_mm2, 
         data[data$Gleason == "Low",]$cells_per_mm2)$p.value
}
p_values <- by(rr_long, rr_long$Metric, get_pvalue)

labels_with_pvalues <- sapply(names(p_values), function(name) {
    sprintf("%s (p = %.3f)", name, p_values[[name]])
})

g <- ggplot(rr_long, aes(x = Gleason, y = cells_per_mm2 / 1000, fill = Gleason)) +
  geom_boxplot(alpha = 0.5, width=0.8, outlier.shape=NA) +
  geom_jitter(position = position_jitter(width = 0.2), size = 1, alpha = 0.7, shape=20) +
  labs(y = "Thousands of cells / mm2") +
  #scale_fill_manual(values = pMMR_colors) +
  facet_wrap(~ Metric, labeller = as_labeller(labels_with_pvalues)) +
  theme_jw() + scale_y_log10()
save_ppdf(g, "whole_slide_immune_boxplot2.pdf", width=6, height=4)
```

```{r clinical_plots}
g <- ggplot(rr, aes(x = Gleason, y = age_surgery_years, fill = Gleason)) +
  geom_boxplot(alpha = 0.5, width=0.8, outlier.shape=NA) +
  geom_jitter(position = position_jitter(width = 0.2), size = 1, alpha = 0.7, shape=20) +
  labs(y = "Age at surgery (years)") +
  theme_jw() 
wilcox.test(rr[Gleason=="High",time_to_progression_days], rr[Gleason=="Low",time_to_progression_days])
save_ppdf(g, "age_boxplot.pdf", width=3, height=3)
```

```{r cohort-statistic}
system(paste("cyftools cellcount ~/Sorger/projects/prostate/allp.cys /tmp/tmp.cys -a 34816 -a 0"), intern=TRUE)
headr <- header_read("/tmp/tmp.cys")
dt <- fread(cmd=paste("cyftools view /tmp/tmp.cys"))
colnames(dt) <- c("sid","cid","cflag","pflag","x","y",headr[tag_type %in% c("CA","MA"), id])

# Gather the count fields to long format
dt_long <- dt[, .(Variable = names(.SD), Count = unlist(.SD)), 
              .SDcols = patterns("_count")]
dt_long$Variable <- gsub("_count$", "", dt_long$Variable)
dt_long$Variable[dt_long$Variable=="0"] <- "Uncalled"
dt_long$Variable[dt_long$Variable=="34816"] <- "CD3+PD1+"

# Plot using ggplot2
g <- ggplot(dt_long, aes(x = Variable, y = Count / 29 / 1000)) +
  geom_bar(stat = "identity") +
  coord_flip() + # Flip to make horizontal bars
  theme_minimal() +
  labs(x = "", y = "Cell counts / tumor (thousands)") + 
  scale_y_continuous(labels = scales::comma) + # Use comma format for y-axis labels
  theme_jw()
save_ppdf(g, "cell_counts_hist.pdf", width=6, height=6)
```

```{r umap}
dt <- fread("cyftools clean -M ~/Sorger/projects/prostate/allp.02.cys - | cyftools rescale - - | cyftools view - -R")[,.(Ki67, AMCAR, HMWCK, CD19, SMA, CD20, CD68, CD163, CD4, CD3d, CD8a, FOXP3, PD1, CD57, CD11c, GranzymeB, CD15, HLADR, CD103, CD31, pTBK1, HLAA, CD44, CD206)]
expm <- t(as.matrix(dt[sample(.N, 99000)]))
colnames(expm) <- seq(ncol(expm))
seurat_obj <- CreateSeuratObject(counts = expm)

# pre-process
seurat_obj <- NormalizeData(seurat_obj)
#seurat_obj <- FindVariableFeatures(seurat_obj, selection.method = "vst", nfeatures = 2000)
seurat_obj <- ScaleData(seurat_obj)
seurat_obj <- RunPCA(seurat_obj, verbose = FALSE, npcs = min(10, ncol(seurat_obj) - 1), features = rownames(seurat_obj))

ElbowPlot(seurat_obj)

# cluster using Louvain
seurat_obj <- FindNeighbors(seurat_obj, dims = 1:10)  # you can choose an appropriate number of dims based on ElbowPlot
seurat_obj <- FindClusters(seurat_obj, resolution = 0.5)  # adjust resolution based on the desired granularity
saveRDS(seurat_obj, "~/Sorger/cache/seurat.rds", compress=FALSE)

# run umap
seurat_obj <- RunUMAP(seurat_obj, dims = 1:10, n_neighbors = 30, min_dist = 0.5)
DimPlot(seurat_obj, group.by = "seurat_clusters")
```

```{r macrophage-tcell}
files <- list.files(path = "~/Sorger/projects/prostate/chain/", full.names = TRUE)
files <- files[grepl("cys$", files)]
dtt <- lapply(files, function(f) {
    cat(basename(f), "\n")
    dt <- fread(cmd=paste("cyftools filter -a 512 -a 256 -T",f,"/tmp/tmp.cys && cyftools mean /tmp/tmp.cys - | cyftools view - -R"))
    dt[, Slide_ID := sub("^(LSP[0-9]+).*", "\\1", basename(f))]
    dt[, margin := "cd163"]
    return(dt)
  })
dtr <- rbindlist(dtt)

dtt <- lapply(files, function(f) {
    cat(basename(f), "\n")
    dt <- fread(cmd=paste("cyftools filter -n 768 -T",f,"/tmp/tmp.cys && cyftools mean /tmp/tmp.cys - | cyftools view - -R"))
    dt[, Slide_ID := sub("^(LSP[0-9]+).*", "\\1", basename(f))]
    dt[, margin := "not_cd163"]
    return(dt)
  })
dtr <- rbind(dtr, rbindlist(dtt))
  
rrm <- fread("~/Sorger/projects/prostate/230803_clinical_data.csv")
rrm <- rrm[!duplicated(Slide_ID)]
rrm[, Gleason := ifelse(surgery_gleason %in% c("4 + 4","4 + 5","5 + 3","5 + 4"), "High", "Low")]
rrm <- merge(data.table::copy(rrm), dtr, by = "Slide_ID", all.x = TRUE)

rr_long <- melt(rrm, id.vars = c("Gleason","margin"), measure.vars = c("CD3d_20r","CD4_20r","CD8a_20r","PD1_20r"), variable.name = "Metric", value.name = "Value")
rr_long[, cells_per_mm2 := Value * 1e6 / (1000^2 * 0.325^2)]
p_values <- by(rr_long, rr_long$Metric, get_pvalue)
labels_with_pvalues <- sapply(names(p_values), function(name) {
    sprintf("%s (p = %.3f)", name, p_values[[name]])
})

g <- ggplot(rr_long, aes(x = margin, y = cells_per_mm2 / 1000, fill = Gleason)) +
  geom_boxplot(alpha = 0.5, width=0.8, outlier.shape=NA) +
  geom_jitter(position = position_jitter(width = 0.2), size = 1, alpha = 0.7, shape=20) +
  labs(y = "Thousands of cells / mm2") +
  #scale_fill_manual(values = pMMR_colors) +
  facet_wrap(~ Metric, labeller = as_labeller(labels_with_pvalues)) +
  theme_jw() + scale_y_log10()
```

```{r lda}
files <- list.files(path = "~/Sorger/projects/prostate/lda", full.names = TRUE)
files <- files[grepl("cys$", files)]
dtt <- lapply(files, function(f) {
    cat(basename(f), "\n")
    dt <- fread(cmd=paste("cyftools filter",f,"/tmp/tmp.cys && cyftools mean /tmp/tmp.cys - | cyftools view - -R"))
    dt[, Slide_ID := sub("^(LSP[0-9]+).*", "\\1", basename(f))]
    #dt[, margin := "cd163"]
    return(dt)
  })
dtr <- rbindlist(dtt)

rr <- fread("~/Sorger/projects/prostate/230803_clinical_data.csv")
rr <- rr[!duplicated(Slide_ID)]
rr[, Gleason := ifelse(surgery_gleason %in% c("4 + 4","4 + 5","5 + 3","5 + 4"), "High", "Low")]
rr <- merge(data.table::copy(rr), dtr, by = "Slide_ID", all.x = TRUE)

rr_long <- melt(rr, id.vars = "Gleason", measure.vars = paste0("topic",seq(10)), variable.name = "Metric", value.name = "Value")
#rr_long[, cells_per_mm2 := Value * 1e6 / (1000^2 * 0.325^2)]

# Assuming the data has two Gleason groups "A" and "B"
get_pvalue <- function(data) {
  wilcox.test(data[data$Gleason == "High",]$Value, 
         data[data$Gleason == "Low",]$Value)$p.value
}
p_values <- by(rr_long, rr_long$Metric, get_pvalue)

labels_with_pvalues <- sapply(names(p_values), function(name) {
    sprintf("%s (p = %.3f)", name, p_values[[name]])
})

g <- ggplot(rr_long, aes(x = Gleason, y = Value, fill = Gleason)) +
  geom_boxplot(alpha = 0.5, width=0.8, outlier.shape=NA) +
  geom_jitter(position = position_jitter(width = 0.2), size = 1, alpha = 0.7, shape=20) +
  labs(y = "Thousands of cells / mm2") +
  #scale_fill_manual(values = pMMR_colors) +
  facet_wrap(~ Metric, labeller = as_labeller(labels_with_pvalues)) +
  theme_jw() + scale_y_log10()
save_ppdf(g, "lda_boxplots.pdf", width=6, height=6)
```

```{r scramble-lda}
files <- list.files(path = "~/Sorger/projects/prostate/scramble", full.names = TRUE)
files <- files[grepl("scramble.ptrdl.cys$", files)]
dtt <- lapply(files, function(f) {
    cat(basename(f), "\n")
    dt <- fread(cmd=paste("cyftools filter",f,"/tmp/tmp.cys && cyftools mean /tmp/tmp.cys - | cyftools view - -R"))
    dt[, Slide_ID := sub("^(LSP[0-9]+).*", "\\1", basename(f))]
    #dt[, margin := "cd163"]
    return(dt)
  })
dtr <- rbindlist(dtt)

rr <- fread("~/Sorger/projects/prostate/230803_clinical_data.csv")
rr <- rr[!duplicated(Slide_ID)]
rr[, Gleason := ifelse(surgery_gleason %in% c("4 + 4","4 + 5","5 + 3","5 + 4"), "High", "Low")]
rr <- merge(data.table::copy(rr), dtr, by = "Slide_ID", all.x = TRUE)

rr_long <- melt(rr, id.vars = "Gleason", measure.vars = paste0("topic",seq(10)), variable.name = "Metric", value.name = "Value")
#rr_long[, cells_per_mm2 := Value * 1e6 / (1000^2 * 0.325^2)]

# Assuming the data has two Gleason groups "A" and "B"
get_pvalue <- function(data) {
  wilcox.test(data[data$Gleason == "High",]$Value, 
         data[data$Gleason == "Low",]$Value)$p.value
}
p_values <- by(rr_long, rr_long$Metric, get_pvalue)

labels_with_pvalues <- sapply(names(p_values), function(name) {
    sprintf("%s (p = %.3f)", name, p_values[[name]])
})

g <- ggplot(rr_long, aes(x = Gleason, y = Value, fill = Gleason)) +
  geom_boxplot(alpha = 0.5, width=0.8, outlier.shape=NA) +
  geom_jitter(position = position_jitter(width = 0.2), size = 1, alpha = 0.7, shape=20) +
  labs(y = "Thousands of cells / mm2") +
  #scale_fill_manual(values = pMMR_colors) +
  facet_wrap(~ Metric, labeller = as_labeller(labels_with_pvalues)) +
  theme_jw() + scale_y_log10()
```

```{r jaccard}
ff <- c("/Users/jeremiahwala/Sorger/projects/prostate/chain/low.cys","/Users/jeremiahwala/Sorger/projects/prostate/chain/high.cys")
#dtt <- lapply(master_files, function(f) {
dtt <- lapply(ff, function(f) {
    cat(basename(f), "\n")
    dt <- fread(cmd=paste("cyftools jaccard",f,"-j"))
    dt[, Slide_ID := sub("^(LSP[0-9]+).*", "\\1", basename(f))]
    #dt[, margin := "cd163"]
    return(dt)
  })
dtr <- rbindlist(dtt)
 
# scrambled
files <- list.files(path = "~/Sorger/projects/prostate/clean/", full.names = TRUE)
files <- files[grepl("cys$", files)]

#dtt <- lapply(files, function(f) {
dtt <- lapply(ff, function(f) {
  cat(basename(f),"\n")
dt <- rbindlist(mclapply(seq(5), function(s) {
    dt <- fread(cmd=paste("cyftools scramble -s",s, f,"- | cyftools jaccard - -j"))
    dt[, Slide_ID := sub("^(LSP[0-9]+).*", "\\1", basename(f))]
    dt[, seed := s]
    return(dt)
  }, mc.cores=5))
  dt[, V3_scramble := mean(V3, na.rm = TRUE), by = c("V1","V2","Slide_ID")]
  return(dt[!duplicated(paste(Slide_ID,V1,V2)), .(V1,V2,Slide_ID,V3_scramble)])
})
dtr_s <- rbindlist(dtt)
saveRDS(dtr_s, "~/cache/dtr_s_high_low_jaccard.rds", compress=FALSE)

# merged dtr
dtr <- merge(dtr, dtr_s[, .(V1, V2, Slide_ID, V3_scramble)], by = c("V1", "V2", "Slide_ID"))
dtr[, Jaccard_score_normalized := V3 / V3_scramble]

# Create a mirrored dataset by switching V1 and V2
mirrored_dtr <- dtr[, .(V1 = V2, V2 = V1, Slide_ID = Slide_ID, V3 = V3, Jaccard_score_normalized = Jaccard_score_normalized)]

# Combine the original and mirrored datasets
combined_dtr <- rbind(dtr[,.(V1, V2, V3, Slide_ID, Jaccard_score_normalized)], mirrored_dtr[,.(V1, V2, V3, Slide_ID, Jaccard_score_normalized)])

# Convert data.table to wide format
wide_dtr <- dcast(combined_dtr, V1 + Slide_ID ~ V2, value.var = "Jaccard_score_normalized")

# Convert wide format to long format
long_dtr <- melt(wide_dtr, id.vars = c("V1", "Slide_ID"))

# Convert V1 and variable to character
long_dtr[, V1 := as.character(V1)]
long_dtr[, variable := as.character(variable)]

# Filter out the lower diagonal
long_dtr <- long_dtr[V1 < variable]

# if jaccard normalized
long_dtr[, value_maxed := ifelse(value > 50, 50, value)]

# Plot heatmap using ggplot2
tcell <- c("CD3d","CD4","CD8a","PD1","FOXP3","AMCAR","SMA","CD20","CD57")
g <- ggplot(long_dtr[V1 %in% tcell & variable %in% tcell], aes(x = V1, y = variable)) +
  geom_tile(aes(fill = log10(value_maxed)), color = "black") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
  theme_minimal() +
  labs(title = "Jaccard Correlation Enrichment", x="",y="",fill = "Correlation") +
  theme_jw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  facet_wrap(~ Slide_ID) +
  coord_fixed(clip = "off") +
  theme(plot.margin = margin(1, 1, 1, 1, "cm")) 
save_ppdf(g, "jaccard_tcell.pdf", width=5, height=4)
```

```{r jaccard}

files <- list.files(path = "~/Sorger/projects/orion/orion_1_74/pearson/", full.names = TRUE)
files <- files[grepl("pearson$", files)]
col_range <- colorRampPalette(c("darkblue", "white", "darkred"))(200)

dtt <- lapply(files, function(f) {
  cat(basename(f), "\n")
  dt <- fread(f)
  
  bl <- c("Hoechst", "Argo550","AF1")
  dt <- dt[!V1 %in% bl & !V2 %in% bl]
  
  # Visualize using ggplot2
  g <- ggplot(data = dt, aes(x = V1, y = V2)) +
  geom_tile(aes(fill = V3), color = "white") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1,1), name="Correlation") +
  #geom_text(aes(label = sprintf("%.2f", value)), vjust = 1) +
  theme_jw() + ggtitle(sub("\\..*$", "", basename(f))) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1), 
        axis.title.x = element_blank(), axis.title.y = element_blank(), 
        legend.position = "none")
  
 # Create a square matrix of dimensions equal to unique values of V1 and V2
labels <- unique(c(dt$V1, dt$V2))
mat <- matrix(0, nrow=length(labels), ncol=length(labels))
rownames(mat) <- labels
colnames(mat) <- labels

# Fill the matrix
for (i in 1:nrow(dt)) {
  mat[dt$V1[i], dt$V2[i]] <- dt$V3[i]
  mat[dt$V2[i], dt$V1[i]] <- dt$V3[i]  # since the relationship is symmetric
}
  
  return(list(g=g, mat=mat, name=sub("\\..*$", "", basename(f))))
})
save_pdf(gridExtra::grid.arrange(grobs = lapply(dtt, function(x) x$g)), "pearson_facet.pdf", width=30, height=30)

##### NON PARALLEL
# Calculate pairwise Mantel tests
n <- length(dtt)
results <- matrix(NA, n, n)
rownames(results) <- names(dtt)
colnames(results) <- names(dtt)

for (i in 1:(n-1)) {
  cat(i,"\n")
  for (j in (i+1):n) {
    test <- mantel(dtt[[i]]$mat, dtt[[j]]$mat, method = "pearson", permutations = 999)
    results[i, j] <- test$statistic
    results[j, i] <- test$statistic
  }
}
##########

compute_mantel <- function(pair) {
  i <- pair[1]
  j <- pair[2]
  
  test <- mantel(dtt[[i]]$mat, dtt[[j]]$mat, method = "pearson", permutations = 999)
  return(list(i = i, j = j, statistic = test$statistic))
}

# Create a list of all pairs of indices
pairs <- list()
for (i in 1:(n-1)) {
  for (j in (i+1):n) {
    pairs <- c(pairs, list(c(i, j)))
  }
}

# Determine the number of cores to use; usually one less than all available cores
num_cores <- detectCores() - 1
system.time(results_list <- mclapply(pairs, compute_mantel, mc.cores = num_cores))

# extract into results matrix
results <- matrix(NA, n, n)
rownames(results) <- sapply(dtt, function(x) x$name)
colnames(results) <- sapply(dtt, function(x) x$name)
for (res in results_list) {
  results[res$i, res$j] <- res$statistic
  results[res$j, res$i] <- res$statistic
}

# Plot Mantel similarity matrix
df_results <- as.data.table(melt(results[!rownames(results) %in% hard_coded_tip, !colnames(results) %in% hard_coded_tip]))
colnames(df_results) <- c("Matrix1", "Matrix2", "Mantel_r")
g <- ggplot(df_results, aes(Matrix1, Matrix2, fill = Mantel_r)) +
  geom_tile() +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
  theme_minimal() +
  labs(title = "Mantel Test Similarity Matrix", fill = "Mantel r")

library(ComplexUpset)

# 1. Calculate the distance matrix.
# Given that the results are correlation coefficients (from Mantel test),
# we can calculate the distance as (1 - correlation coefficient).
# This makes perfect correlations have a distance of 0 and no correlation a distance of 1.
dist_matrix <- 1 - abs(results[!rownames(results) %in% hard_coded_tip, !colnames(results) %in% hard_coded_tip])

# 2. Perform hierarchical clustering
clustering <- hclust(as.dist(dist_matrix))
dendrogram <- as.dendrogram(clustering)

# 3. Rearrange the results matrix based on clustering order
order <- order.dendrogram(dendrogram)
clustered_results <- results[order, order]

# 4. Plot the clustered matrix
df_clustered_results <- melt(clustered_results)
colnames(df_clustered_results) <- c("Matrix1", "Matrix2", "Mantel_r")

g <- ggplot(df_clustered_results, aes(Matrix1, Matrix2, fill = Mantel_r)) +
  geom_tile() +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Clustered Mantel Test Similarity Matrix", fill = "Mantel r")

# Using heatmap.2 for visualization with dendrogram
save_pdf(heatmap.2(clustered_results, 
          main = "Clustered Mantel Test Similarity Matrix", 
          notecol="black",      # change font color of cell labels to black
          density.info="none",  # turns off density plot inside color legend
          trace="none",         # turns off trace lines inside the heat map
          margins =c(8,9),      # widens margins around plot
          dendrogram = "row",   # only draw a row dendrogram
          col = colorRampPalette(c("blue", "white", "red"))(25),
          Colv = NULL),          # keep the column order as it is
         "mantel_dendrogram_pearson_nontip.pdf", width=20, height=20)
```

```{r scratch-plots}

g = ggplot() + geom_point(data = dtt[SlideID=="LSP12657"], aes(x=x,y=y), size = 0.01, color="black") + theme_minimal() + coord_fixed(ratio = 1) +
  geom_point(data = dtt[SlideID=="LSP12657" & CD20p == TRUE],aes(x=x,y=y), color="green", size = 0.01) + 
  geom_point(data=dtt[SlideID=="LSP12657" & FOXP3CD3p == TRUE],aes(x=x,y=y), color="red", size = 0.01)
png("~/Downloads/tmp.png", width = 8000, height = 8000, res = 200)
print(g)
dev.off()

```

```{r statistical-powre}
library(survival)
library(powerSurvEpi)

# Study parameters
nE <- 280  # Experimental group (immune-activated)
nC <- 420  # Control group (immune-depleted)
alpha <- 0.05  # Two-sided significance level
HR <- 0.66  # Hypothesized hazard ratio (immune-activated vs immune-depleted)
pC <- 0.35  # Control group event rate (probability of metastasis)

# Compute pE using the HR formula
pE <- 1 - (1 - pC)^HR  # Expected failure rate in the experimental group

# Compute power using the correct function
power <- powerCT.default(
  nE = nE,  # Number of participants in experimental group
  nC = nC,  # Number of participants in control group
  pE = pE,  # Probability of failure in experimental group
  pC = pC,  # Probability of failure in control group
  RR = HR,  # Hazard Ratio
  alpha = alpha  # Significance level
)

# Output power estimate
cat("Power of the log-rank test:", round(power, 4), "\n")

```

```{r david}

files <- list.files(path = "/Users/jeremiahwala/Dropbox_HMS/2025-Amiryousefi-Wala/Data/jeremiah_coord", full.names = TRUE)
trayslide = str_extract(files, "Tray\\d+_Slide\\d+")

dt.david <- rbindlist(lapply(files[str_extract(files, "Tray\\d+_Slide\\d+") %in% crr$whole_slide_image], function(x) {
  dt <- fread(x)
  trayslide = str_extract(x, "Tray\\d+_Slide\\d+")
  dt[, tray := trayslide]
  slideid = crr[whole_slide_image==trayslide, Slide_ID]
  dt[, Slide_ID := slideid]

  
  return(dt)
}))
dt.david[, area := diff(range(y))*diff(range(x)), by="Slide_ID"]

## plot
setkey(dt.david, Slide_ID)
allg <- lapply(unique(dt.david$Slide_ID), function(x) {
  
    dt = dt.david[x]

    g <- ggplot() + geom_point(data=dt[label >= 0], aes(x=x, y=y, color=as.factor(label)), size=0.2) + 
    geom_point(data=dt[label == -1], aes(x=x, y=y), color="gray", size=0.2) + 
    coord_fixed(ratio=1) + theme_bw() + theme(legend.position = "none") + 
    ggtitle(x)
    return(g)
})
library(patchwork)
combined_plot <- wrap_plots(allg, ncol = 5)
ggsave("~/Desktop/grid_5x5_patchwork.pdf", combined_plot, width = 50, height = 50, units = "in", limitsize = FALSE)
ggsave("~/Desktop/grid_5x5_patchwork.png",
       combined_plot,
       width = 50,
       height = 50,
       units = "in",
       limitsize=FALSE,
       dpi = 300)  # or dpi = 600 for publication quality

## plot correlation
dtt[, area := diff(range(y))*diff(range(x)), by="Slide_ID"]
##7232 = CD20 + CD3 + CD4 + CD8
ab=dtt[, .(cycif_lymphocytes = sum(fcheckor(pflag, 7232)), cycif_area = area[1]), by="Slide_ID"]
abd = dt.david[, .(cellvit_lymphocytes = .N, david_area=area[1]), by="Slide_ID"]
abb = merge(ab, abd, by="Slide_ID")
abb[, area_ratio := david_area / cycif_area]
abb[, area_ratio := area_ratio / mean(area_ratio)]
library(ggpmisc)
library(ggrepel)
g <- ggplot(abb, aes(x = cycif_lymphocytes * area_ratio, y = cellvit_lymphocytes)) +
  geom_point(size = 3, alpha = 0.7) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray40") +  # y = x line
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  #stat_poly_eq(
  #  aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
  #  formula = y ~ x,
  #  parse = TRUE,
   # label.x.npc = "left",
  #  label.y.npc = 0.95
 # ) +
  labs(
    title = "Correlation between CyCIF and CellVit lymphocyte counts",
    x = "CyCIF Lymphocytes",
    y = "CellVit Lymphocytes"
  ) +
  theme_minimal(base_size = 14) + 
  scale_x_log10() + scale_y_log10() + geom_text_repel(aes(label=Slide_ID))
pdf("~/Desktop/Correlation.pdf", width=10,height=10) 
print(g)
dev.off()

## cycif cluster plot
setkey(dtt, Slide_ID)
allg <- lapply(unique(dt.david$Slide_ID), function(x) {
  
    dt = dtt[x]
    dt = dt[fcheckor(pflag, 7232)]

    g <- ggplot() + geom_point(data=dt[tls_id > 0], aes(x=-x, y=-y, color=as.factor(tls_id)), size=0.2) + 
    geom_point(data=dt[tls_id == 0], aes(x=-x, y=-y), color="gray", size=0.2) + 
    coord_fixed(ratio=1) + theme_bw() + theme(legend.position = "none") + 
    ggtitle(x) + xlim(c(-13000,0)) + ylim(c(-10000,0))
    return(g)
})

ggsave("~/Desktop/cycif_grid_5x5_patchwork.png",
       combined_plot,
       width = 50,
       height = 50,
       units = "in",
       limitsize=FALSE,
       dpi = 300)  # or dpi = 600 for publication quality
```

```{r CD163-tls}
rrt= rr[margin=="tumor"]
ab = dtt[, .(TLScount = length(unique(tls_id[tls_id >= 0]))), by="Slide_ID"]
abb <- merge(ab, rrt, by="Slide_ID")

g <- ggplot(data=abb, aes(TLScount, FOXP3_50r)) + geom_point() +   geom_smooth(method = "lm", se = TRUE) + stat_poly_eq(
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
  formula = y ~ x,
    parse = TRUE,
    label.x.npc = "left",
    label.y.npc = 0.95
  )

```

```{r recalc-cd8-crc}

lf_crc = list.files("~/Dropbox_HMS/projects/orion/orion_1_74/csv_chain_coy2", full.names=TRUE)

CRCCD8FLAG=256
CRCCD4FLAG=64
CRCCD20FLAG=1024
CRCCD3FLAG=4096
areas_crc <- parallel::mclapply(lf_crc, function(x) {
  cat("working on", x, "\n")
  dt <- fread(cmd=paste("cut -f1-6 -d','", x))
  return(cycif_disc_union_area(dt[fcheck(cflag, 8)])$area)
},mc.cores=8)
names(areas_crc) <- lf_crc

ff_crc <- lapply(lf_crc, function(x) {
  cat("working on", x, "\n")
  dt <- fread(x)
  new_rate = dt[fcheck(cflag, 8) & fcheck(pflag, CRCCD8FLAG ), .N] / areas_crc[[x]] * 1e6
  old_rate = dt[fcheck(cflag, 8), mean(CD8_50r)]
  id <- sub(".*(LSP\\d+).*", "\\1", x)
  return(list(Slide_ID=id, new_rate = new_rate, old_rate = old_rate))
})

abb_crc =rbindlist(lapply(ff_crc, as.data.table))
abb_crc = merge(abb_crc, crr_crc, by="Slide_ID")
abb_crc[pMMR=="pMMR", median(new_rate)]
abb_crc[pMMR=="dMMR",median(new_rate)]
abb_crc[pMMR=="pMMR", median(old_rate)]
abb_crc[pMMR=="dMMR",median(old_rate)]
g <- ggplot(abb_crc, aes(x=new_rate, y=old_rate, color=pMMR)) + 
  geom_text_repel(aes(label=Slide_ID)) + 
  geom_smooth(method = "lm", se = TRUE) +
  geom_point() + 
  theme_bw() + 
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray40") + 
  scale_x_log10(name="CD8/mm2 - Total area") + scale_y_log10("CD8/mm2 - Mean of small areas")# y = x line
saveRDS(abb_crc, "~/Desktop/prostate_crc_abb_crc_cd8.rds")

ab4 = readRDS("~/Desktop/prostate_crc_abb_crc_cd3cd4.rds")
ab8 = readRDS("~/Desktop/prostate_crc_abb_crc_cd3cd8.rds")
ab20 = readRDS("~/Desktop/prostate_crc_abb_crc_cd20.rds")
paste("dMMR: ", ab4[pMMR=="dMMR", mean(new_rate)], "pMMR:", ab4[pMMR=="pMMR", mean(new_rate)])
paste("dMMR: ", ab8[pMMR=="dMMR", mean(new_rate)], "pMMR:", ab8[pMMR=="pMMR", mean(new_rate)])
paste("dMMR: ", ab20[pMMR=="dMMR", mean(new_rate)], "pMMR:", ab20[pMMR=="pMMR", mean(new_rate)])
```

```{r recalc-cd8-prostate}

lf = list.files("/Users/jeremiahwala/Dropbox_HMS/Primary_prostate_CyCIF_TME_manuscript_2023/primary_data/chain", full.names=TRUE)
lf = lf[grepl("LSP[0-9]+.csv", lf)]
CD8FLAG=4096
CD4FLAG=1024
CD3FLAG=2048

TARGET = c("G1","G2","G3","G4","G5")

## CD3/8 plot
lapply(lf, fu1nction(x) {
  dt <- fread(x)
  dt[, tumor := fcase(
    bitops::bitAnd(cflag, 4096)  > 0, "G1",
    bitops::bitAnd(cflag, 8192)  > 0, "G2",
    bitops::bitAnd(cflag, 16384) > 0, "G3",
    bitops::bitAnd(cflag, 32768) > 0, "G4",
    bitops::bitAnd(cflag, 65536) > 0, "G5",
    default = "stroma"
  )] 
  dt[, cd3cd8 := ifelse(fcheck(pflag, CD3FLAG + CD8FLAG), "cd8","no")]
  nn = sub("\\.csv","",basename(x))
  g <- ggplot(dt[tumor != "stroma"][sample(.N, min(20000,.N))]) + 
    geom_point(aes(x=x,y=y,color=cd3cd8), size=0.5) + 
    coord_fixed(ratio=1) + theme_bw() + ggtitle(nn)
  cat(nn, "\n")
  pdf(paste0("~/Desktop/prostate_plots/cd8",nn,".pdf"), width=15, height=15)
  print(g)
  dev.off()
})

## tumor plot
lapply(lf_crc, function(x) {
  dt <- fread(x)
dt[, tumor := fcase(
  bitops::bitAnd(cflag, 8)  > 0, "tumor",
  default = "stroma"
)] 
dt[, cd3cd8 := ifelse(fcheck(pflag, CRCCD3FLAG + CRCCD8FLAG), "cd8","no")]
nn = sub("\\.csv","",basename(x))
  g <- ggplot(dt[tumor != "stroma"][sample(.N, min(20000,.N))]) + 
    geom_point(aes(x=x,y=y,color=cd3cd8), size=0.5) + 
    coord_fixed(ratio=1) + 
    
                theme_bw() + ggtitle(nn)
  cat(nn, "\n")
  pdf(paste0("~/Desktop/crc_plots/cd8",nn,".pdf"), width=15, height=15)
  print(g)
  dev.off()
})


areas <- parallel::mclapply(lf, function(x) {
  cat("working on", x, "\n")
  dt <- fread(x)
  dt[, tumor := fcase(
    bitops::bitAnd(cflag, 4096)  > 0, "G1",
    bitops::bitAnd(cflag, 8192)  > 0, "G2",
    bitops::bitAnd(cflag, 16384) > 0, "G3",
    bitops::bitAnd(cflag, 32768) > 0, "G4",
    bitops::bitAnd(cflag, 65536) > 0, "G5",
    default = "stroma"
)] 
  
  ix <- dt$tumor %in% TARGET
  
  if (sum(ix) ==0) ## if no tumor
    return(list())
  return(cycif_disc_union_area(dt[ix])$area)
},mc.cores=8)
names(areas) <- lf

TARGET = c("G1","G2","G3","G4","G5")
ff <- lapply(lf, function(x) {
  cat("working on", x, "\n")
  dt <- fread(x)
  dt[, tumor := fcase(
    bitops::bitAnd(cflag, 4096)  > 0, "G1",
    bitops::bitAnd(cflag, 8192)  > 0, "G2",
    bitops::bitAnd(cflag, 16384) > 0, "G3",
    bitops::bitAnd(cflag, 32768) > 0, "G4",
    bitops::bitAnd(cflag, 65536) > 0, "G5",
    default = "stroma"
)]   
  ix <- dt$tumor %in% TARGET

  if (sum(ix)==0) ## if no tumor
    return(list())
  new_rate = dt[ix & fcheck(pflag, CD4FLAG), .N] / areas[[x]] *1e6 / 4
  old_rate = dt[ix, mean(CD4_50r/4)]
  id <- sub(".*(LSP\\d+).*", "\\1", x)
  return(list(Slide_ID=id, new_rate = new_rate, old_rate = old_rate))
})
abb =rbindlist(lapply(ff, as.data.table))
abb = merge(abb, crr, by="Slide_ID")
abb[Gleason=="High", median(new_rate)]
abb[Gleason=="Low",median(new_rate)]
wilcox.test(abb[Gleason=="High", new_rate],abb_crc[pMMR=="pMMR", new_rate])
wilcox.test(abb[Gleason=="Low",new_rate], abb_crc[pMMR=="pMMR",new_rate])
wilcox.test(abb[Gleason=="High",new_rate], abb_crc[pMMR=="dMMR",new_rate])
wilcox.test(abb[Gleason=="Low",new_rate], abb_crc[pMMR=="dMMR",new_rate])
g <- ggplot(abb, aes(x=new_rate, y=old_rate, color=Gleason)) + 
  geom_text_repel(aes(label=Slide_ID)) + 
  geom_smooth(method = "lm", se = TRUE) +
  geom_point() + 
  theme_bw() + 
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray40") + 
  scale_x_log10(name="CD4/mm2 - Total area") + scale_y_log10("CD4/mm2 - Mean of small areas")# y = x line

abb[, SlideID := factor(Slide_ID, levels = Slide_ID[order(new_rate)])]
long_result <- melt(abb, id.vars = c("SlideID","Gleason"), 
                    measure.vars = c("new_rate"),
                    variable.name = "marker", 
                    value.name = "avg_value")

wilcox.test(abb[Gleason=="High",new_rate], abb[Gleason=="Low",new_rate], alternative="two.sided")
t.test(abb[Gleason=="High",new_rate], abb[Gleason=="Low",new_rate])
g <- ggplot(long_result, aes(x = SlideID, y = avg_value, fill = Gleason), color="black") +
  geom_bar(stat = "identity", position = "dodge", color="black") +
  scale_y_continuous(expand = c(0,0)) + 
  labs(x = "Orion Slide", y = "Average Value", fill = "Marker") +
  theme_jw() + coord_flip() + xlab("Orion Slide ID") + ylab("Fraction of all cells") +  scale_fill_manual(values=gleason_colors) + 
  geom_hline(yintercept=ab4[pMMR=="pMMR",median(new_rate)], color="#CE6631") + geom_hline(yintercept=ab4[pMMR=="dMMR",median(new_rate)], color="#EE1C50")
save_ppdf(g, "cd4only_waterfall.pdf", width=4, height=3.5)

wilcox.test(abb[Gleason=="High", new_rate],ab20[pMMR=="pMMR", new_rate], alternative = "two.sided")
wilcox.test(abb[Gleason=="Low",new_rate], ab20[pMMR=="pMMR",new_rate], alternative = "two.sided")
wilcox.test(abb[Gleason=="High",new_rate], ab20[pMMR=="dMMR",new_rate], alternative = "two.sided")
wilcox.test(abb[Gleason=="Low",new_rate], ab20[pMMR=="dMMR",new_rate], alternative = "two.sided")

groups <- c("G1","G2","G3","G4","G5")

subregion <- lapply(lf, function(x) {
  cat("working on", x, "\n")
  dt <- fread(x)
  
  # classify tumor/stroma
  dt[, tumor := fcase(
    bitAnd(cflag, 4096)  > 0, "G1",
    bitAnd(cflag, 8192)  > 0, "G2",
    bitAnd(cflag, 16384) > 0, "G3",
    bitAnd(cflag, 32768) > 0, "G4",
    bitAnd(cflag, 65536) > 0, "G5",
    default = "stroma"
  )]
  
  # inner loop over groups
  lapply(groups, function(GGG) {
    ix <- dt$tumor == GGG
    
    if (sum(ix) == 0) return(NULL)  # skip empty
    
    area <- cycif_disc_union_area(dt[ix])$area
    
    cd8_rate  <- dt[ix & fcheck(pflag, CD8FLAG + CD3FLAG), .N] / area * 1e6 / 4
    cd20_rate <- dt[ix & fcheck(pflag, CD20FLAG), .N]            / area * 1e6 / 4
    cd4_rate  <- dt[ix & fcheck(pflag, CD4FLAG + CD3FLAG), .N] / area * 1e6 / 4
    
    id <- sub(".*(LSP\\d+).*", "\\1", x)
    
    list(Slide_ID = id,
         cd8_rate  = cd8_rate,
         cd20_rate = cd20_rate,
         cd4_rate  = cd4_rate,
         region    = GGG)
  })
}) 
subregion <- rbindlist(unlist(subregion, recursive = FALSE), fill = TRUE)
subregion[, region := factor(region, levels = c("G1","G2","G3","G4","G5"))]

# long format
long <- melt(
  subregion,
  id.vars = c("Slide_ID","region"),
  measure.vars = c("cd8_rate","cd20_rate","cd4_rate"),
  variable.name = "marker",
  value.name = "rate"
)

# nicer labels
long[, marker := fifelse(marker == "cd8_rate", "CD8 rate",
                  fifelse(marker == "cd20_rate", "CD20 rate", "CD4 rate"))]

pd <- position_dodge(width = 0.8)

g = ggplot(long, aes(x = region, y = rate, fill = marker)) +
  geom_boxplot(width = 0.7, position = pd, outlier.shape = 16, outlier.size = 1.8) +
  # mean Â± SE error bars
  stat_summary(
    fun = mean, fun.min = function(z) mean(z) - sd(z)/sqrt(length(z)),
    fun.max = function(z) mean(z) + sd(z)/sqrt(length(z)),
    geom = "errorbar", width = 0.25, position = pd, color = "black", linewidth = 0.5
  ) +
  stat_summary(fun = mean, geom = "point", position = pd, shape = 21, color = "black", size = 2) +
  labs(x = "Region", y = "Cells per mmÂ² (rates)", fill = "Marker") +
  theme_minimal(base_size = 12) +
  theme(panel.grid.minor = element_blank())



# mean across samples for each region Ã marker
long <- melt(
  subregion,
  id.vars = c("Slide_ID","region"),
  measure.vars = c("cd8_rate","cd4_rate","cd20_rate"),
  variable.name = "marker",
  value.name = "rate"
)
long[, marker := factor(marker,
                        levels = c("cd8_rate","cd4_rate","cd20_rate"),
                        labels = c("CD8","CD4","CD20"))]
means <- long[, .(mean_rate = mean(rate, na.rm = TRUE)), by = .(region, marker)]

# colors similar to your example
cols <- c(CD20 = "#E41A1C", CD4 = "#377EB8", CD8 = "#4DAF4A")

g = ggplot(means, aes(x = region, y = mean_rate, fill = marker)) +
  geom_col(width = 0.9, color="black") +                        # stacked bars of means
  scale_fill_manual(values = cols, name = "Marker") +
  labs(x = NULL, y = "Cell fraction (mean)") +    # adjust label text as you prefer
  theme_minimal(base_size = 12) +
  theme(panel.grid.minor = element_blank(),
        legend.position = "right")
save_ppdf(g, "stacked_barplot.pdf", width=4,height=4)

```

```{r stacked-barchart}

library(ggplot2)
library(clinfun)   # for jonckheere.test()
library(tidyr)     # for pivot_longer()
# 1) Define your estimated proportions
groups <- factor(paste0("G", 1:5),
                 levels = paste0("G", 1:5),
                 ordered = TRUE)
lvls <- c("G1","G2","G3","G4","G5")

CD8 <- subregion[region %chin% lvls, 
          .(mean_cd8 = mean(cd8_rate, na.rm = TRUE)),
          keyby = .(region = factor(region, levels = lvls))]$mean_cd8
CD4 <- subregion[region %chin% lvls, 
          .(mean_cd4 = mean(cd4_rate, na.rm = TRUE)),
          keyby = .(region = factor(region, levels = lvls))]$mean_cd4
CD20 <- subregion[region %chin% lvls, 
          .(mean_cd20 = mean(cd20_rate, na.rm = TRUE)),
          keyby = .(region = factor(region, levels = lvls))]$mean_cd20


df <- data.frame(groups, CD4, CD8, CD20)
# 2) Reshape to long form for ggplot
df_long <- pivot_longer(df,
                        cols      = c("CD4","CD8","CD20"),
                        names_to  = "marker",
                        values_to = "proportion")
# 3) Compute regression-based p-values for each marker
x_num   <- as.numeric(df$groups)
lm_cd4  <- summary(lm(CD4  ~ x_num, data = df))
lm_cd8  <- summary(lm(CD8  ~ x_num, data = df))
lm_cd20 <- summary(lm(CD20 ~ x_num, data = df))
p_cd4   <- signif(lm_cd4$coefficients["x_num","Pr(>|t|)"], 3)
p_cd8   <- signif(lm_cd8$coefficients["x_num","Pr(>|t|)"], 3)
p_cd20  <- signif(lm_cd20$coefficients["x_num","Pr(>|t|)"],3)
# 4) Compute a single JonckheereâTerpstra test on the total proportions per group
tot     <- df$CD4 + df$CD8 + df$CD20
jt_tot  <- jonckheere.test(tot, as.integer(df$groups), alternative = "increasing")
p_tot   <- signif(jt_tot$p.value, 3)
# 5) Build subtitle
subtitle_text <- paste0(
  "CD4 (lm) p=",   p_cd4,
  "   CD8 (lm) p=", p_cd8,
  "   CD20 (lm) p=",p_cd20,
  "   Total (JT) p=", p_tot
)
# 6) Plot
ggplot(df_long, aes(x = groups, y = proportion, fill = marker)) +
  
  # stacked bars
  geom_bar(stat = "identity", position = "stack", color = "black") +
  
  # linear trend lines + 95% CI
  geom_smooth(aes(x = as.numeric(groups), 
                  y = proportion, 
                  color = marker,
                  group = marker),
              method = "lm", se = TRUE, size = 1, fill = "grey80") +
  
  # fill & line colors
  scale_fill_manual(name = "Marker",
                    values = c("CD20" = "#e41a1c",
                               "CD8"  = "#4daf4a",
                               "CD4"  = "#377eb8")) +
  scale_color_manual(values = c("CD20" = "#e41a1c",
                                "CD8"  = "#4daf4a",
                                "CD4"  = "#377eb8"),
                     guide = FALSE) +
  
  # titles and subtitle with pâvalues
  labs(
    title    = "Proportions of CD4, CD8 and CD20 Across Groups",
    subtitle = subtitle_text,
    x        = "Group",
    y        = "Proportion"
  ) +
  
  # minimal theme + grid
  theme_minimal() +
  theme(
    panel.grid.major   = element_line(color = "grey90"),
    panel.grid.minor   = element_blank(),
    legend.position    = "right",
    legend.title       = element_text(size = 12),
    legend.text        = element_text(size = 10),
    plot.title         = element_text(size = 16, face = "bold"),
    plot.subtitle      = element_text(size = 12),
    axis.title         = element_text(size = 14),
    axis.text          = element_text(size = 12)
  )
p2 <- ggplot(df_long, aes(x = as.numeric(groups), y = proportion, color = marker)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = TRUE, size = 1, fill = "grey80") +
  scale_x_continuous(breaks = 1:5, labels = levels(df$groups)) +
  scale_color_manual(name = "Marker",
                     values = c("CD20" = "#e41a1c",
                                "CD8"  = "#4daf4a",
                                "CD4"  = "#377eb8")) +
  labs(x = "Group", y = "Proportion") +
  theme_minimal() +
  theme(
    panel.grid.major = element_line(color = "grey90"),
    panel.grid.minor = element_blank(),
    legend.position  = "right",
  )
p2

```

```{r roi-areas}
lf_roi <- list.files("/Users/jeremiahwala/Dropbox_HMS/projects/orion/orion_1_74/rois", full.names = TRUE)

ff_roi <- lapply(lf_roi, function(x) {
  cat(x, "\n")
  df <- read.csv(x,stringsAsFactors = FALSE)
   points_str <- df[["all_points"]]

  # Parse into list of x,y matrices
  coords_list <- lapply(points_str, function(s) {
    # split on spaces into "x,y" tokens
    pairs <- strsplit(s, " ")[[1]]
    # split each token into numeric x,y
    xy <- do.call(rbind, strsplit(pairs, ","))
    matrix(as.numeric(xy), ncol = 2, byrow = FALSE,
           dimnames = list(NULL, c("x","y")))
  })
  names(coords_list) <- ifelse(grepl("undefined",df$Name), df$Text, df$Name)
  
  areas <- sapply(coords_list[grepl("tumor", names(coords_list))], poly_area)
  
  if (length(areas)==0)
    return(NA)
  
  return(max(areas))
})
names(ff_roi) <- sub("\\.roi\\.csv$", "", basename(lf_roi))
dt.areas.roi <- data.table(area_roi=unlist(ff_roi)/1e6*0.325*0.325, SlideID=sub("\\.roi\\.csv$", "", basename(lf_roi)))

dt.areas.crc = data.table(area=unlist(areas_crc)/1e6, SlideID=sub("\\.csv$","",basename(names(areas_crc))))

dtt = merge(dt.areas.crc, dt.areas.roi, by="SlideID", all.x=TRUE)
g <- ggplot(dtt, aes(x=area_roi, y=area)) + geom_point() + geom_smooth(method = "lm", se = TRUE)

# Shoelace area for a single polygon (matrix with columns x,y)
poly_area <- function(xy) {
  if (is.null(dim(xy)) || nrow(xy) < 3) return(NA_real_)
  x <- xy[,1]; y <- xy[,2]
  # close ring if last point != first point
  if (x[1] != x[length(x)] || y[1] != y[length(y)]) {
    x <- c(x, x[1]); y <- c(y, y[1])
  }
  0.5 * abs(sum(x[-1] * y[-length(y)] - y[-1] * x[-length(x)]))
}

# First polygon as a data.frame
poly_df <- as.data.frame(coords_list[[3]])
colnames(poly_df) <- c("x","y")

g <- ggplot(poly_df, aes(x, y)) +
  geom_polygon(fill = NA, color = "red", linewidth = 1) +
  geom_point(color = "blue", size = 2) +
  coord_fixed(ratio = 1) +
  labs(x = "X", y = "Y") +
  theme_minimal()
```

